<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<title>Go源码分析(5) - 数据结构 - Jovan&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



    <meta name="description" content="介绍常见的数据结构,比如channel、slice、map等,通过对其底层实现原理的分析,来更好的使用这些数据结构。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go源码分析(5) - 数据结构">
<meta property="og:url" content="https://www.ulovecode.com/2020/02/27/Go/Golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(5)-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Jovan&#39;s Blog">
<meta property="og:description" content="介绍常见的数据结构,比如channel、slice、map等,通过对其底层实现原理的分析,来更好的使用这些数据结构。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://static001.infoq.cn/resource/image/32/78/323e61d0aa4eb543dc3b8d5faaa3aa78.jpg?x-oss-process=image/crop,y_59,w_1279,h_730/resize,w_1280,h_847">
<meta property="article:published_time" content="2020-02-27T12:44:00.000Z">
<meta property="article:modified_time" content="2020-02-27T12:44:00.000Z">
<meta property="article:author" content="Jovan">
<meta property="article:tag" content="Golang源码分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://static001.infoq.cn/resource/image/32/78/323e61d0aa4eb543dc3b8d5faaa3aa78.jpg?x-oss-process=image/crop,y_59,w_1279,h_730/resize,w_1280,h_847">







    <link rel="icon" href="//md.ulovecode.com/static/images/avatar/logo.jpg">

<link rel="stylesheet" href="https://code.bdstatic.com/npm/bulma@0.7.5/css/bulma.min.css">
<link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/font-awesome/5.8.1/css/all.min.css">
<!--<link rel="stylesheet" href="https://fonts.proxy.ustclug.org/css?family=Noto+Serif+SC:500|Source+Code+Pro:500&display=swap">-->
<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/lxgwwenkaimono-regular.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/lxgwwenkaimono-light.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/lxgwwenkaimono-bold.css">
<!--<link rel="stylesheet" href="https://code.bdstatic.com/npm/lxgw-wenkai-lite-webfont@1.6.0/lxgwwenkailite-regular.css">-->
<!--<link rel="stylesheet" href="https://code.bdstatic.com/npm/lxgw-wenkai-lite-webfont@1.6.0/lxgwwenkailite-light.css">-->
<!--<link rel="stylesheet" href="https://code.bdstatic.com/npm/lxgw-wenkai-lite-webfont@1.6.0/lxgwwenkailite-bold.css">-->

<link rel="stylesheet" href="https://code.bdstatic.com/npm/highlight.js@10.1.0/styles/github.css">


    
        
    
        
    
    <link rel="stylesheet" href="https://code.bdstatic.com/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://code.bdstatic.com/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
        

<link rel="stylesheet" href="https://code.bdstatic.com/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
        
    
        

<link rel="stylesheet" href="https://md.ulovecode.com/static/css/back-to-top.css">


    
        

    
        
    
        

    
        
    
        
    

    
        
    


<link rel="stylesheet" href="https://md.ulovecode.com/static/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="//md.ulovecode.com/static/images/avatar/logo.jpg" alt="Go源码分析(5) - 数据结构" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ulovecode">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="https://static001.infoq.cn/resource/image/32/78/323e61d0aa4eb543dc3b8d5faaa3aa78.jpg?x-oss-process=image/crop,y_59,w_1279,h_730/resize,w_1280,h_847" alt="Go源码分析(5) - 数据结构">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-27T12:44:00.000Z">2020-02-27</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Go/">Go</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Go/Golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Golang源码分析</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 8272 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                Go源码分析(5) - 数据结构
            
        </h1>
        <div class="content">
            <p>介绍常见的数据结构,比如channel、slice、map等,通过对其底层实现原理的分析,来更好的使用这些数据结构。</p>
<a id="more"></a>
<h2 id="一、切片"><a href="#一、切片" class="headerlink" title="一、切片"></a><strong>一、切片</strong></h2><h3 id="Slice数据结构"><a href="#Slice数据结构" class="headerlink" title="Slice数据结构"></a><strong>Slice数据结构</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span></span><br><span class="line">	<span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>array指针指向底层数组</li>
<li>len表示切片长度</li>
<li>cap表示底层数组容量</li>
</ul>
<h3 id="slice的三种初始化方式"><a href="#slice的三种初始化方式" class="headerlink" title="slice的三种初始化方式"></a><strong>slice的三种初始化方式</strong></h3><h4 id="make初始化"><a href="#make初始化" class="headerlink" title="make初始化"></a><strong>make初始化</strong></h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeslice</span><span class="hljs-params">(et *_type, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;</span><br><span class="line">    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> The len &gt; maxElements check here is not strictly necessary,</span></span><br><span class="line">    <span class="hljs-comment">// but it produces a 'len out of range' error instead of a 'cap out of range' error</span></span><br><span class="line">    <span class="hljs-comment">// when someone does make([]T, bignumber). 'cap out of range' is true too,</span></span><br><span class="line">    <span class="hljs-comment">// but since the cap is only being supplied implicitly, saying len is clearer.</span></span><br><span class="line">    <span class="hljs-comment">// See issue 4085.</span></span><br><span class="line">    maxElements := maxSliceCap(et.size)</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">len</span>) &gt; maxElements &#123;</span><br><span class="line">        <span class="hljs-built_in">panic</span>(errorString(<span class="hljs-string">"makeslice: len out of range"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &lt; <span class="hljs-built_in">len</span> || <span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>) &gt; maxElements &#123;</span><br><span class="line">        <span class="hljs-built_in">panic</span>(errorString(<span class="hljs-string">"makeslice: cap out of range"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p := mallocgc(et.size*<span class="hljs-keyword">uintptr</span>(<span class="hljs-built_in">cap</span>), et, <span class="hljs-literal">true</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> slice&#123;p, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>make()</code>方法会调用<code>makeslice()</code>的方法,会对 slice的 array 指针进行分配地址,创建后可直接使用。</p>
<h4 id="struct"><a href="#struct" class="headerlink" title="[]struct{}{}"></a><strong>[]struct{}{}</strong></h4><p>使用该方法创建后的对象可以直接使用。</p>
<h4 id="new-struct"><a href="#new-struct" class="headerlink" title="new([]struct{})"></a><strong>new([]struct{})</strong></h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">	array := <span class="hljs-built_in">new</span>([]<span class="hljs-keyword">int</span>)</span><br><span class="line">	(*array)[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// nil[0] = 1     err</span></span><br><span class="line">	<span class="hljs-built_in">println</span>(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该方式只是创建一个该数组类型的指针,调用<code>runtime.newobject</code>方法 ,new是返回 slice 的地址。指针类型初始化后,值为nil,如果对该类型进行赋值会发生空指针异常,创建后不可直接使用。</p>
<h3 id="slice的扩容机制"><a href="#slice的扩容机制" class="headerlink" title="slice的扩容机制"></a><strong>slice的扩容机制</strong></h3><h4 id="使用append-方法的扩容"><a href="#使用append-方法的扩容" class="headerlink" title="使用append()方法的扩容:"></a><strong>使用<code>append()</code>方法的扩容:</strong></h4><p>使用<code>append()</code>向Slice添加一个元素的实现步骤如下:</p>
<ol>
<li>假如Slice容量够用,则将新元素追加进去,Slice.len++,返回原Slice</li>
<li>原Slice容量不够,则将Slice先扩容,扩容后得到新Slice</li>
<li>将新元素追加进新Slice,Slice.len++,返回新的Slice。</li>
</ol>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">slice</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="hljs-comment">// 省略一些判断...</span></span><br><span class="line"></span><br><span class="line">    newcap := old.<span class="hljs-built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="hljs-built_in">cap</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">            <span class="hljs-comment">// and prevent an infinite loop.</span></span><br><span class="line">            <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="hljs-number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// Set newcap to the requested cap when</span></span><br><span class="line">            <span class="hljs-comment">// the newcap calculation overflowed.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;</span><br><span class="line">                newcap = <span class="hljs-built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 省略一些后续...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果原Slice容量小于1024,则新Slice容量将扩大为原来的2倍;</li>
<li>如果原Slice容量大于等于1024,则新Slice容量将扩大为原来的1.25倍;</li>
</ul>
<h3 id="slice的复制"><a href="#slice的复制" class="headerlink" title="slice的复制"></a><strong>slice的复制</strong></h3><h4 id="使用copy-进行复制"><a href="#使用copy-进行复制" class="headerlink" title="使用copy()进行复制"></a><strong>使用<code>copy()</code>进行复制</strong></h4><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slicecopy</span><span class="hljs-params">(to, fm slice, width <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">int</span></span> &#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> fm.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> || to.<span class="hljs-built_in">len</span> == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := fm.<span class="hljs-built_in">len</span></span><br><span class="line">	<span class="hljs-keyword">if</span> to.<span class="hljs-built_in">len</span> &lt; n &#123;</span><br><span class="line">		n = to.<span class="hljs-built_in">len</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> width == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(slicecopy)</span><br><span class="line">		racewriterangepc(to.array, <span class="hljs-keyword">uintptr</span>(n*<span class="hljs-keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">		racereadrangepc(fm.array, <span class="hljs-keyword">uintptr</span>(n*<span class="hljs-keyword">int</span>(width)), callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanwrite(to.array, <span class="hljs-keyword">uintptr</span>(n*<span class="hljs-keyword">int</span>(width)))</span><br><span class="line">		msanread(fm.array, <span class="hljs-keyword">uintptr</span>(n*<span class="hljs-keyword">int</span>(width)))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size := <span class="hljs-keyword">uintptr</span>(n) * width</span><br><span class="line">	<span class="hljs-keyword">if</span> size == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// common case worth about 2x to do here</span></span><br><span class="line">		<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">		*(*<span class="hljs-keyword">byte</span>)(to.array) = *(*<span class="hljs-keyword">byte</span>)(fm.array) <span class="hljs-comment">// known to be a byte pointer</span></span><br><span class="line">	&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">		memmove(to.array, fm.array, size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>copy()</code>内置函数拷贝两个切片时,<code>memmove()</code>方法同时将被拷贝切片的array的切片的值逐一拷贝到新到切片,拷贝数量取两个切片长度的最小值。</p>
<h4 id="使用slice-start-end-方法进行复制"><a href="#使用slice-start-end-方法进行复制" class="headerlink" title="使用slice[start:end]方法进行复制"></a><strong>使用slice[start:end]方法进行复制</strong></h4><p>使用该方法,同时将被拷贝切片的array的切片的指针拷贝到新到切片的指针上,同时len变为end-start,cap则和原slice一样。</p>
<h2 id="二、channel"><a href="#二、channel" class="headerlink" title="二、channel"></a><strong>二、channel</strong></h2><h3 id="chan数据结构"><a href="#chan数据结构" class="headerlink" title="chan数据结构"></a><strong>chan数据结构</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="hljs-keyword">uint16</span></span><br><span class="line">	closed   <span class="hljs-keyword">uint32</span></span><br><span class="line">	elemtype *_type <span class="hljs-comment">// element type</span></span><br><span class="line">	sendx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// send index</span></span><br><span class="line">	recvx    <span class="hljs-keyword">uint</span>   <span class="hljs-comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="hljs-comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="hljs-comment">// list of send waiters</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>qcount 当前队列中剩余元素个数</li>
<li>dataqsiz 环形队列长度,即可以存放的元素个数</li>
<li>buf 环形队列指针</li>
<li>elemsize 每个元素的大小</li>
<li>closed 标识关闭状态</li>
<li>elemtype 元素类型</li>
<li>sendx 队列下标,指示元素写入时存放到队列中的位置</li>
<li>recvx 队列下标,指示元素从队列的该位置读出</li>
<li>recvq 等待读消息的goroutine队列</li>
<li>sendq 等待写消息的goroutine队列</li>
<li>lock 互斥锁,chan不允许并发读写</li>
</ul>
<p>hchan 实际上就是一个环形队列,buf指向环形队列,dataqsiz、qcount 分别指定了队列的容量和当前使用量,其中recvq队列和sendq队列是一个链表的结构,包含该goroutine和该groutine的数据,然后再来看一下waitq这个数据结构。</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitq是链表的定义,包含一个头结点和一个尾结点。我们可能对节点中存放对内容感到疑惑,再来看一下sudog这个数据结构。</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// The following fields are protected by the hchan.lock of the</span></span><br><span class="line">    <span class="hljs-comment">// channel this sudog is blocking on. shrinkstack depends on</span></span><br><span class="line">    <span class="hljs-comment">// this for sudogs involved in channel ops.</span></span><br><span class="line"></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">    <span class="hljs-comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">    isSelect <span class="hljs-keyword">bool</span></span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">    <span class="hljs-comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">    <span class="hljs-comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">    <span class="hljs-comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">    acquiretime <span class="hljs-keyword">int64</span></span><br><span class="line">    releasetime <span class="hljs-keyword">int64</span></span><br><span class="line">    ticket      <span class="hljs-keyword">uint32</span></span><br><span class="line">    parent      *sudog <span class="hljs-comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink    *sudog <span class="hljs-comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail    *sudog <span class="hljs-comment">// semaRoot</span></span><br><span class="line">    c           *hchan <span class="hljs-comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sudog结构可以实际上是一个对应goroutine上保存着其对应的data数据,类似于java中的ThreadLocal。其中：</p>
<ul>
<li>g 代表着 G-M-P模型中的 G,sudog 是对g的封装便于在 csp 模型中 g 可以同时阻塞在不同的 channel 上</li>
<li>elem 用于存储 goroutine 的数据;读通道时,数据会从 hchan 的队列中拷贝到 sudog 的 elem 域;写通道时,数据则是由 sudog 的elem 域拷贝到 hchan 的队列中。</li>
</ul>
<p>下面给出他们的结构图:</p>
<p><img src="https://changkun.de/golang/assets/chan.png" width="90%" height="40%"><br><!--![图 1 ](https://changkun.de/golang/assets/chan.png)--></p>
<h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a><strong>创建channel</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-keyword">int64</span>)</span> *<span class="hljs-title">hchan</span></span> &#123;</span><br><span class="line">    elem := t.elem</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// compiler checks this but be safe.</span></span><br><span class="line">   <span class="hljs-comment">// 异常判断 元素类型大小限制</span></span><br><span class="line">    <span class="hljs-keyword">if</span> elem.size &gt;= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">16</span> &#123;</span><br><span class="line">        throw(<span class="hljs-string">"makechan: invalid channel element type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 异常判断 对齐限制</span></span><br><span class="line">    <span class="hljs-keyword">if</span> hchanSize%maxAlign != <span class="hljs-number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">        throw(<span class="hljs-string">"makechan: bad alignment"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// maxAlloc 是 Arena 区域的最大值,缓冲元素的大小与hchan相加不能超过 缓冲槽大小</span></span><br><span class="line">    <span class="hljs-keyword">if</span> size &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">int64</span>(<span class="hljs-keyword">uintptr</span>(size)) != size || (elem.size &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">uintptr</span>(size) &gt; (_MaxMem-hchanSize)/elem.size) &#123;</span><br><span class="line">        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"makechan: size out of range"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> c *hchan</span><br><span class="line">    <span class="hljs-comment">// 不是指针类型</span></span><br><span class="line">    <span class="hljs-keyword">if</span> elem.kind&amp;kindNoPointers != <span class="hljs-number">0</span> || size == <span class="hljs-number">0</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 在一个调用中分配内存。       </span></span><br><span class="line">        <span class="hljs-comment">// 在这种情况下,Hchan不包含GC感兴趣的指针：</span></span><br><span class="line">        <span class="hljs-comment">// buf指向相同的分配,elemtype是持久的。</span></span><br><span class="line">        <span class="hljs-comment">// SudoG从它们自己的线程中引用,因此无法将其收集。</span></span><br><span class="line">        <span class="hljs-comment">// TODO（dvyukov,rlh）：重新考虑何时收集器可以移动分配的对象。</span></span><br><span class="line">        c = (*hchan)(mallocgc(hchanSize+<span class="hljs-keyword">uintptr</span>(size)*elem.size, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))</span><br><span class="line">        <span class="hljs-keyword">if</span> size &gt; <span class="hljs-number">0</span> &amp;&amp; elem.size != <span class="hljs-number">0</span> &#123;</span><br><span class="line">            c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// 竞争检测器使用此位置进行同步</span></span><br><span class="line">            <span class="hljs-comment">// 还可以防止我们超出分配范围（请参见问题9401）。</span></span><br><span class="line">            c.buf = unsafe.Pointer(c)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 是指针类型 分配hchan结构体 buf单独分配</span></span><br><span class="line">        c = <span class="hljs-built_in">new</span>(hchan)</span><br><span class="line">        c.buf = newarray(elem, <span class="hljs-keyword">int</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 初始化元素类型的大小</span></span><br><span class="line">    c.elemsize = <span class="hljs-keyword">uint16</span>(elem.size)</span><br><span class="line">  <span class="hljs-comment">// 初始化元素的类型</span></span><br><span class="line">    c.elemtype = elem</span><br><span class="line">  <span class="hljs-comment">// 初始化 channel 的容量</span></span><br><span class="line">    c.dataqsiz = <span class="hljs-keyword">uint</span>(size)</span><br><span class="line">    <span class="hljs-keyword">if</span> debugChan &#123;</span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"makechan: chan="</span>, c, <span class="hljs-string">"; elemsize="</span>, elem.size, <span class="hljs-string">"; elemalg="</span>, elem.alg, <span class="hljs-string">"; dataqsiz="</span>, size, <span class="hljs-string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建channel的过程实际上是初始化hchan结构。其中类型信息和缓冲区长度由make语句传入,buf的大小则与元素大小和缓冲区长度共同决定。</p>
<h3 id="向channel写数据"><a href="#向channel写数据" class="headerlink" title="向channel写数据"></a><strong>向channel写数据</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// entry point for c &lt;- x from compiled code</span></span><br><span class="line"><span class="hljs-comment">//go:nosplit</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc(unsafe.Pointer(&amp;c)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>, callerpc <span class="hljs-keyword">uintptr</span>)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> !block &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">"chan send (nil chan)"</span>, traceEvGoStop, <span class="hljs-number">2</span>)</span><br><span class="line">        throw(<span class="hljs-string">"unreachable"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> !block &amp;&amp; c.closed == <span class="hljs-number">0</span> &amp;&amp; ((c.dataqsiz == <span class="hljs-number">0</span> &amp;&amp; c.recvq.first == <span class="hljs-literal">nil</span>) ||</span><br><span class="line">        (c.dataqsiz &gt; <span class="hljs-number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span></span><br><span class="line">    <span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 1</span></span><br><span class="line">    <span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">        <span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">        send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 2</span></span><br><span class="line">    <span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">        qp := chanbuf(c, c.sendx)</span><br><span class="line">        <span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        c.sendx++</span><br><span class="line">        <span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">            c.sendx = <span class="hljs-number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount++</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> !block &#123;</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.releasetime = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        mysg.releasetime = <span class="hljs-number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">    <span class="hljs-comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    mysg.waitlink = <span class="hljs-literal">nil</span></span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.selectdone = <span class="hljs-literal">nil</span></span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">    c.sendq.enqueue(mysg)</span><br><span class="line">    goparkunlock(&amp;c.lock, <span class="hljs-string">"chan send"</span>, traceEvGoBlockSend, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// someone woke us up.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">        throw(<span class="hljs-string">"G waiting list is corrupted"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.waiting = <span class="hljs-literal">nil</span></span><br><span class="line">    <span class="hljs-keyword">if</span> gp.param == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> c.closed == <span class="hljs-number">0</span> &#123;</span><br><span class="line">            throw(<span class="hljs-string">"chansend: spurious wakeup"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"send on closed channel"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">    <span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">        blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mysg.c = <span class="hljs-literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>if c == nil</code>判断 channel 为空  向其中发送数据将会永久阻塞<ol>
<li><code>if !block</code>如果非阻塞返回 false</li>
<li><code>gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)</code>如果阻塞, gopark 会使当前 goroutine 挂起,通过 unlockf 唤醒;调用gopark时传入的unlockf为nil,会被一直休眠</li>
</ol>
</li>
<li>在不获取锁定的情况下检查失败的非阻塞操作。如果检测到,将直接返回false<ol>
<li><code>!block &amp;&amp; c.closed == 0</code>非阻塞并且没有关闭channel<ol>
<li><code>(c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil)</code>无缓冲channel并且消费者环形队列头结点为空,说明channel还没有准备好。</li>
<li><code>(c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)</code>有缓冲channel中存储的元素数量与容量相等,容量已经满了,不能够缓存更多的。</li>
</ol>
</li>
</ol>
</li>
<li><code>lock(&amp;c.lock)</code>对channel进行加锁</li>
<li><code>c.closed != 0</code>如果channel在途中关闭,<code>unlock(&amp;c.lock)</code>解锁并 panic</li>
<li><code>sg := c.recvq.dequeue(); sg != nil</code>当有 goroutine 在 recvq 队列上等待时,跳过缓存队列,<code>send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)</code>将消息直接发给 reciever goroutine;dequeue 从等待接受的 goroutine 队列链表获取一个sudog,<code>goready()</code>唤醒阻塞的 goroutine</li>
<li><code>c.qcount &lt; c.dataqsiz</code>缓存队列未满,将消息复制到缓存队列上并移动 sendx 下标,hchan buf 数据量增加。<ol>
<li><code>typedmemmove(c.elemtype, qp, ep)</code>数据拷贝到 buf 中</li>
<li><code>c.sendx++</code>index 移动</li>
<li><code>c.sendx == c.dataqsiz</code>环形队列如果已经加到最大,<code>c.sendx = 0</code>就置 0</li>
<li><code>c.qcount++</code>缓冲元素数量加 1</li>
<li><code>unlock(&amp;c.lock)</code>解锁返回</li>
</ol>
</li>
<li><code>if !block</code>阻塞 解锁直接返回 false</li>
<li><code>gp := getg()</code>返回指向当前goroutine的指针</li>
<li><code>mysg := acquireSudog()</code>从sudogcache中获取sudog</li>
<li>对<code>mysg</code>进行一系列的赋值</li>
<li><code>c.sendq.enqueue(mysg)</code>  加入到写阻塞的等待队列</li>
<li><code>goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)</code>将当前gorountine挂起休眠</li>
<li><code>KeepAlive(ep)</code>保证数据不被回收</li>
<li><code>mysg != gp.waiting</code>此时被唤醒 gp.waiting不是当前的 mysg 直接 panic</li>
<li><code>gp.waiting = nil</code>说明waiting是当前waiting,将gp中的waiting置为nil</li>
<li><code>gp.param == nil</code>唤醒时传递的参数为 nil 说明出问题了直接 panic</li>
<li><code>mysg.c = nil</code>sudog 中的 hchan 置为 nil</li>
<li><code>releaseSudog(mysg)</code>释放 sudog</li>
</ol>
<p>从上面的可以看出来<code>channelsend()</code>的处理逻辑为：</p>
<ul>
<li>如果当前 Channel 的 recvq 上存在已经被阻塞的 Goroutine,那么会直接将数据发送给当前的 Goroutine 并将其设置成下一个运行的协程。</li>
<li>如果 Channel 存在缓冲区并且其中还有空闲的容量,我们就会直接将数据直接存储到当前缓冲 区 sendx 所在的位置上。</li>
<li>如果都不满足上面的两种情况,就会创建一个 sudog 结构并加入 Channel 的 sendq 队 列并更新到 Goroutine 的 waiting 字段上,同时当前的 Goroutine 就会陷入阻塞等待 其他的协程向 Channel 接收数据,一旦有其它的协程向 Channel 接收数据时就会唤醒当前的 Goroutine;发送数据的过程中包含几个会触发 Goroutine 调度的时机,首先是发送数据时发现 Channel 上存在等待接收数据的 Goroutine,这是会立刻设置处理器的 runnext 属 性,但是并不会立刻触发调度,第二个时机是发送数据时并没有找到接收方并且缓冲区已经满 了,这时就会将自己加入 Channel 的 sendq 队列并立刻调用 goparkunlock 触发 Goroutine 的调度让出处理器的使用权。</li>
</ul>
<p><strong>直接将消息发送给reciever是怎样的呢？</strong></p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">skip</span> <span class="hljs-title">int</span>)</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;</span><br><span class="line">            racesync(c, sg)</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// Pretend we go through the buffer, even though</span></span><br><span class="line">            <span class="hljs-comment">// we copy directly. Note that we need to increment</span></span><br><span class="line">            <span class="hljs-comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">            qp := chanbuf(c, c.recvx)</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">            c.recvx++</span><br><span class="line">            <span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">                c.recvx = <span class="hljs-number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 写入的数据不为空</span></span><br><span class="line">    <span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 将数据拷贝到 hchan</span></span><br><span class="line">        sendDirect(c.elemtype, sg, ep)</span><br><span class="line">    <span class="hljs-comment">// sudog 中数据置为 nil</span></span><br><span class="line">        sg.elem = <span class="hljs-literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 取数 goroutine</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">  <span class="hljs-comment">// 传入 sudug 使 param 不为空</span></span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 唤醒 goroutine </span></span><br><span class="line">    goready(gp, skip+<span class="hljs-number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>sendDirect</code>函数将发送的消息拷贝到接收方持有的目标内存地址上,取出<code>gp := sg.g</code>,然后将当前sg的数据赋值回去,使用<code>goready(gp, skip+1)</code>将接收方 Goroutine 的状态修改成 Grunnable 并更新发送方所在处理器 P 的 runnext 属性,当处理器 P 再次发生调度时就会优先执行 runnext 中的协程。</p>
<h3 id="从channel读数据"><a href="#从channel读数据" class="headerlink" title="从channel读数据"></a><strong>从channel读数据</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-keyword">bool</span>)</span> <span class="hljs-params">(selected, received <span class="hljs-keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="hljs-comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="hljs-comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="hljs-built_in">print</span>(<span class="hljs-string">"chanrecv: chan="</span>, c, <span class="hljs-string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">if</span> !block &#123;</span><br><span class="line">			<span class="hljs-keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)</span><br><span class="line">		throw(<span class="hljs-string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">	<span class="hljs-comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">	<span class="hljs-comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="hljs-comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">	<span class="hljs-comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">	<span class="hljs-comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">	<span class="hljs-comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">	<span class="hljs-comment">// and report that the receive cannot proceed.</span></span><br><span class="line">	<span class="hljs-comment">//</span></span><br><span class="line">	<span class="hljs-comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">	<span class="hljs-comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">	<span class="hljs-keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="hljs-number">0</span> &amp;&amp; c.sendq.first == <span class="hljs-literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="hljs-number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="hljs-number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">var</span> t0 <span class="hljs-keyword">int64</span></span><br><span class="line">	<span class="hljs-keyword">if</span> blockprofilerate &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &amp;&amp; c.qcount == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">		<span class="hljs-comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="hljs-comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="hljs-comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="hljs-comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">		recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="hljs-number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="hljs-number">0</span></span><br><span class="line">	<span class="hljs-keyword">if</span> t0 != <span class="hljs-number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="hljs-number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="hljs-comment">//在分配elem和排队mysg之间没有堆栈拆分</span></span><br><span class="line">    <span class="hljs-comment">//在gp.waiting上copystack可以找到它的地方。</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="hljs-literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="hljs-literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// someone woke us up</span></span><br><span class="line">	<span class="hljs-keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="hljs-string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="hljs-literal">nil</span></span><br><span class="line">	<span class="hljs-keyword">if</span> mysg.releasetime &gt; <span class="hljs-number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="hljs-number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="hljs-literal">nil</span></span><br><span class="line">	gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">	mysg.c = <span class="hljs-literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法与<code>chansend()</code>没有太大的区别,主要讲两个不同的地方。</p>
<ul>
<li><code>if sg := c.sendq.dequeue(); sg != nil</code>如果有 send 生产者阻塞在队列中,<code>recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)</code>直接从 send 生产者取数据</li>
<li><code>c.recvq.enqueue(mysg)</code>否则 goroutine 加入到读阻塞等待队列</li>
</ul>
<p>所以大致逻辑为：</p>
<ul>
<li>如果 Channel 上的 sendq 队列中存在挂起的 Goroutine,就会将 recvx 索引所在的数 据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区中。</li>
<li>如果 Channel 的缓冲区中包含数据就会直接从 recvx 所在的索引上进行读取</li>
<li>在默认情况下会直接挂起当前的 Goroutine,将 sudog 结构加入 recvq 队列并更新 Goroutine 的 waiting 属性,最后陷入休眠等待调度器的唤醒;在从管道中接收数据的过 程中,其实会在两个时间点触发 Goroutine 的调度,首先空的 Channel 意味着永远接收不 到消息,那么就会直接挂起当前 Goroutine,第二个时间点是缓冲区中不存在数据,在这时也 会直接挂起当前的 Goroutine 等待发送方发送数据。</li>
</ul>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">skip</span> <span class="hljs-title">int</span>)</span> &#123;</span><br><span class="line">  <span class="hljs-comment">// 缓存队列不为空,直接从生产者获取数据</span></span><br><span class="line">    <span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">            racesync(c, sg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// copy data from sender</span></span><br><span class="line">            recvDirect(c.elemtype, sg, ep)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// Queue is full. Take the item at the</span></span><br><span class="line">        <span class="hljs-comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">        <span class="hljs-comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">        <span class="hljs-comment">// queue is full, those are both the same slot.</span></span><br><span class="line">    <span class="hljs-comment">// 有 send 阻塞在这里,从 buf 中获取数据</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">            raceacquire(qp)</span><br><span class="line">            racerelease(qp)</span><br><span class="line">            raceacquireg(sg.g, qp)</span><br><span class="line">            racereleaseg(sg.g, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// copy data from queue to receiver</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 将 buf 中未读的当前位置数据拷贝给消费者</span></span><br><span class="line">        typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 将阻塞的生产者数据拷贝此位置</span></span><br><span class="line">        typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">    <span class="hljs-comment">// 接收元素索引向后移动</span></span><br><span class="line">        c.recvx++</span><br><span class="line">    <span class="hljs-comment">// 环形队列如果已经加到最大就置 0</span></span><br><span class="line">        <span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="hljs-number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="hljs-comment">// 环形队列读取的索引位置就是写入数据环形的末端</span></span><br><span class="line">        c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 数据置为 nil</span></span><br><span class="line">    sg.elem = <span class="hljs-literal">nil</span></span><br><span class="line">  <span class="hljs-comment">// 获取 SudoG 中的 goroutine 传递给 param 参数</span></span><br><span class="line">    gp := sg.g</span><br><span class="line">    unlockf()</span><br><span class="line">    gp.param = unsafe.Pointer(sg)</span><br><span class="line">    <span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        sg.releasetime = cputicks()</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="hljs-comment">// 唤醒 sendq 里面 SudoG 对应的 g</span></span><br><span class="line">    goready(gp, skip+<span class="hljs-number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a><strong>关闭channel</strong></h3><p>关闭通道设置chan关闭标志位,<code>closed=1</code></p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">		<span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.closed = <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// release all readers</span></span><br><span class="line">	<span class="hljs-keyword">for</span> &#123;</span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">			<span class="hljs-keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="hljs-literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">		<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// release all writers (they will panic)</span></span><br><span class="line">	<span class="hljs-keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">			<span class="hljs-keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="hljs-literal">nil</span></span><br><span class="line">		<span class="hljs-keyword">if</span> sg.releasetime != <span class="hljs-number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="hljs-literal">nil</span></span><br><span class="line">		<span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">	<span class="hljs-keyword">for</span> !glist.empty() &#123;</span><br><span class="line">		gp := glist.pop()</span><br><span class="line">		gp.schedlink = <span class="hljs-number">0</span></span><br><span class="line">		goready(gp, <span class="hljs-number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>c == nil</code>  // 关闭为 nil 的 hchan 直接 panic</li>
<li><code>lock(&amp;c.lock)</code>获取同步锁</li>
<li><code>if c.closed != 0</code>已关闭 hchan 释放锁 panic</li>
<li><code>c.closed = 1</code>将 closed 置为 1</li>
<li><code>sg := c.recvq.dequeue()</code>释放所有的读者<code>if sg == nil break</code></li>
<li><code>sg := c.sendq.dequeue()</code>释放所有的写者<code>if sg == nil break</code></li>
<li><code>unlock(&amp;c.lock)</code>释放同步锁</li>
<li><code>goready(gp, 3)</code>将接收队列和发送队列全部唤醒</li>
</ol>
<h2 id="三、map"><a href="#三、map" class="headerlink" title="三、map"></a><strong>三、map</strong></h2><p>Golang中map由链式哈希表实现,主要涉及创建、插入、查找、删除等基本操作,而核心<br>涉及到Map的冲突解决、扩容机制及迁移策略,这也是Map中最难理解的部分。</p>
<h3 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a><strong>map数据结构</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// A header for a Go map.</span></span><br><span class="line"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">	<span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="hljs-comment">// Make sure this stays in sync with the compiler's definition.</span></span><br><span class="line">	count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="hljs-keyword">uint8</span></span><br><span class="line">	B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="hljs-keyword">uint16</span> <span class="hljs-comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// hash seed</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line">	extra *mapextra <span class="hljs-comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>count</code>表示当前哈希表中的元素数量。</li>
<li><code>B</code>表示当前哈希表持有的 buckets 数量,B为2的对数,2^B。</li>
<li><code>hash0</code>是哈希的种子,它能为哈希函数的结果引入随机性,这个值在创建哈希表时确定,并在 调用哈希函数时作为参数传入。</li>
<li><code>buckets</code>2^B个Buckets的桶</li>
<li><code>oldbuckets</code>是哈希在扩容时用于保存之前<code>buckets</code>的字段,它的大小是当前<code>buckets</code>的一半。</li>
</ul>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// mapextra holds fields that are not present on all maps.</span></span><br><span class="line"><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;</span><br><span class="line">	<span class="hljs-comment">// If both key and value do not contain pointers and are inline, then we mark bucket</span></span><br><span class="line">	<span class="hljs-comment">// type as containing no pointers. This avoids scanning such maps.</span></span><br><span class="line">	<span class="hljs-comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets</span></span><br><span class="line">	<span class="hljs-comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.</span></span><br><span class="line">	<span class="hljs-comment">// overflow and oldoverflow are only used if key and value do not contain pointers.</span></span><br><span class="line">	<span class="hljs-comment">// overflow contains overflow buckets for hmap.buckets.</span></span><br><span class="line">	<span class="hljs-comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span></span><br><span class="line">	<span class="hljs-comment">// The indirection allows to store a pointer to the slice in hiter.</span></span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// nextOverflow holds a pointer to a free overflow bucket.</span></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">type</span> <span class="hljs-keyword">struct</span> Bucket &#123;</span><br><span class="line">    <span class="hljs-comment">// tophash generally contains the top byte of the hash value</span></span><br><span class="line">	<span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span></span><br><span class="line">	<span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span></span><br><span class="line">	tophash [bucketCnt]<span class="hljs-keyword">uint8</span></span><br><span class="line">	<span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt values.</span></span><br><span class="line">	<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the values together makes the</span></span><br><span class="line">	<span class="hljs-comment">// code a bit more complicated than alternating key/value/key/value/... but it allows</span></span><br><span class="line">	<span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span></span><br><span class="line">	<span class="hljs-comment">// Followed by an overflow pointer.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tophash</code>是个长度为8的数组,哈希值相同的键(准确的说是哈希值低位相同的键)存入当前bucket时会将哈希值的高位存储在该数组中,以方便后续匹配。</li>
<li><code>overflow</code>指针指向的是下一个bucket,据此将所有冲突的键连接起来。</li>
<li><code>data</code>其中BUCKETSIZE是用宏定义的8,每个bucket中存放最多8个key/value对,存放顺序是key/key/key/…value/value/value,如此存放是为了节省 字节对齐带来的空间浪费。 如果多于8个,那么会申请一个新的bucket,并将它与之前的bucket链起来。</li>
</ul>
<h3 id="平衡因子选取"><a href="#平衡因子选取" class="headerlink" title="平衡因子选取"></a><strong>平衡因子选取</strong></h3><p>扩容的填充因子是多少呢？如果grow的太频繁,会造成空间的利用率很低, 如果很久才grow,会形成很多的overflow buckets,查找的效率也会下降。 这个平衡点如何选取呢(在go中,这个平衡点是有一个宏控制的(#define LOAD 6.5), 它的意思是这样的,如果table中元素的个数大于table中能容纳的元素的个数, 那么就触发一次grow动作。那么这个6.5是怎么得到的呢？作者给出了测试的结果：</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">       LOAD    %overflow  bytes/entry     hitprobe    missprobe</span><br><span class="line">       <span class="hljs-number">4.00</span>         <span class="hljs-number">2.13</span>        <span class="hljs-number">20.77</span>         <span class="hljs-number">3.00</span>         <span class="hljs-number">4.00</span></span><br><span class="line">       <span class="hljs-number">4.50</span>         <span class="hljs-number">4.05</span>        <span class="hljs-number">17.30</span>         <span class="hljs-number">3.25</span>         <span class="hljs-number">4.50</span></span><br><span class="line">       <span class="hljs-number">5.00</span>         <span class="hljs-number">6.85</span>        <span class="hljs-number">14.77</span>         <span class="hljs-number">3.50</span>         <span class="hljs-number">5.00</span></span><br><span class="line">       <span class="hljs-number">5.50</span>        <span class="hljs-number">10.55</span>        <span class="hljs-number">12.94</span>         <span class="hljs-number">3.75</span>         <span class="hljs-number">5.50</span></span><br><span class="line">       <span class="hljs-number">6.00</span>        <span class="hljs-number">15.27</span>        <span class="hljs-number">11.67</span>         <span class="hljs-number">4.00</span>         <span class="hljs-number">6.00</span></span><br><span class="line">       <span class="hljs-number">6.50</span>        <span class="hljs-number">20.90</span>        <span class="hljs-number">10.79</span>         <span class="hljs-number">4.25</span>         <span class="hljs-number">6.50</span></span><br><span class="line">       <span class="hljs-number">7.00</span>        <span class="hljs-number">27.14</span>        <span class="hljs-number">10.15</span>         <span class="hljs-number">4.50</span>         <span class="hljs-number">7.00</span></span><br><span class="line">       <span class="hljs-number">7.50</span>        <span class="hljs-number">34.03</span>         <span class="hljs-number">9.73</span>         <span class="hljs-number">4.75</span>         <span class="hljs-number">7.50</span></span><br><span class="line">       <span class="hljs-number">8.00</span>        <span class="hljs-number">41.10</span>         <span class="hljs-number">9.40</span>         <span class="hljs-number">5.00</span>         <span class="hljs-number">8.00</span></span><br><span class="line"></span><br><span class="line">%overflow   = percentage of buckets which have an overflow bucket</span><br><span class="line">bytes/entry = overhead bytes used per key/value pair</span><br><span class="line">hitprobe    = # of entries to check when looking up a present key</span><br><span class="line">missprobe   = # of entries to check when looking up an absent key</span><br></pre></td></tr></table></figure>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a><strong>冲突解决</strong></h3><p>就像我们之前所提到的,在通常情况下,哈希函数输入的范围一定会远远大于输出的范围,所以在使用哈希表时一定会遇到冲突,哪怕我们使用了完美的哈希函数,当输入的键足够多最终也会造成冲突。</p>
<h4 id="map使用了拉链法"><a href="#map使用了拉链法" class="headerlink" title="map使用了拉链法"></a><strong>map使用了拉链法</strong></h4><p>在一个性能比较好的哈希表中,每一个桶中都应该有 0~1 个元素,有时会有 2~3 个,很少会超过这个数量,计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销,使用拉链法实现的哈希也有装载因子这一概念：装载因子 := 元素数量 / 桶数量</p>
<h3 id="map创建"><a href="#map创建" class="headerlink" title="map创建"></a><strong>map创建</strong></h3><p><code>make([Type]Type)</code></p>
<p>当不指定map元素数量时,使用make_small函数创建hmap结构,但并不初始化桶。产生哈希种子–&gt;返回。</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap_small</span><span class="hljs-params">()</span> *<span class="hljs-title">hmap</span></span> &#123;            </span><br><span class="line">    h := <span class="hljs-built_in">new</span>(hmap)</span><br><span class="line">    h.hash0 = fastrand()          <span class="hljs-comment">/* 创建哈希种子 */</span></span><br><span class="line">    <span class="hljs-keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>make([Type]Type, len)</code></p>
<p>指定元素数量,当元素数量小于8并且小于1&lt;&lt;B*6.5时,B = 0,此时仍然不会初始化桶指针buckets,只产生哈希种子返回,在使用的过程中初始化；其他情况设定B的值,并对桶指针buckets进行初始化。</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-keyword">int</span>, h *hmap)</span> *<span class="hljs-title">hmap</span></span> &#123;</span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="hljs-keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">    <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="hljs-number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        h = <span class="hljs-built_in">new</span>(hmap)                <span class="hljs-comment">/* 新建hmap结构 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    h.hash0 = fastrand()             <span class="hljs-comment">/* 产生哈希种子 */</span></span><br><span class="line"></span><br><span class="line">    B := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">0</span>)</span><br><span class="line">    <span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;    <span class="hljs-comment">/* 确定B的值 */</span></span><br><span class="line">        B++</span><br><span class="line">    &#125;</span><br><span class="line">    h.B = B</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;                    <span class="hljs-comment">/* B != 0 时初始化桶指针buckets */</span></span><br><span class="line">        <span class="hljs-keyword">var</span> nextOverflow *bmap</span><br><span class="line">        h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)    <span class="hljs-comment">/* 初始化桶指针 buckets并分配空间 */</span></span><br><span class="line">        <span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="hljs-built_in">new</span>(mapextra)</span><br><span class="line">            h.extra.nextOverflow = nextOverflow         <span class="hljs-comment">/* 设置溢出桶 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map查找过程"><a href="#map查找过程" class="headerlink" title="map查找过程"></a><strong>map查找过程</strong></h3><p><code>mapaccess1</code>指针返回到<code>h[k]</code>。 永远不会返回<code>nil</code>,而是会参考返回零对象的值类型,如果key是没有在map上。 注：返回的指针可以保持整个map的存活,所以不要抓住它很长时间</p>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        pc := funcPC(mapaccess1)</span><br><span class="line">        racereadpc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">        raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        msanread(key, t.key.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;            <span class="hljs-comment">/* 判断哈希表中是否含有数据 */</span></span><br><span class="line">        <span class="hljs-keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">            t.key.alg.hash(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;         <span class="hljs-comment">/* 是否并发写 */</span></span><br><span class="line">        throw(<span class="hljs-string">"concurrent map read and map write"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))      <span class="hljs-comment">/* 计算键的哈希值 */</span></span><br><span class="line">    m := bucketMask(h.B)                                <span class="hljs-comment">/* 1&lt;&lt;h.B -1 ,低B位掩码*/</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))    <span class="hljs-comment">/* 找到相应的桶,hash&amp;m为第n个桶 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            m &gt;&gt;= <span class="hljs-number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">        <span class="hljs-keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    top := tophash(hash)            <span class="hljs-comment">/* 计算该键tophash的值 */</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;                            <span class="hljs-comment">/* 依次查找桶或溢出桶的元素 */</span></span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;          <span class="hljs-comment">/* 依次遍历桶中的每个key, bucketCnt=8 */</span></span><br><span class="line">            <span class="hljs-keyword">if</span> b.tophash[i] != top &#123;                          <span class="hljs-comment">/* 如果找到top值,则比较第i个key */</span></span><br><span class="line">                <span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))  <span class="hljs-comment">/* 求key地址 */</span></span><br><span class="line">            <span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> alg.equal(key, k) &#123;   <span class="hljs-comment">/* 比较键是否相等。如果相等,则找到key对应的值 */</span></span><br><span class="line">                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))</span><br><span class="line">                <span class="hljs-keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">                    v = *((*unsafe.Pointer)(v))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>按key的类型采用相应的hash算法得到key的hash值。</li>
<li>将hash值的低位与hmpa.B取模确定bucket位置。</li>
<li>先比较hash值高位与bucket的<code>tophash[i]</code>是否相等,如果相等则再比较bucket的第i个的key与所给的key是否相等。<ol>
<li>如果相等,则返回其对应的value。</li>
<li>反之,在<code>overflow</code>buckets 中按照上述方法继续寻找。</li>
</ol>
</li>
<li>如果当前处于搬迁过程,则优先从<code>oldbuckets</code>查找</li>
</ol>
<h3 id="map插入过程"><a href="#map插入过程" class="headerlink" title="map插入过程"></a><strong>map插入过程</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">"assignment to entry in nil map"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        pc := funcPC(mapassign)</span><br><span class="line">        racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">        raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(key, t.key.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        throw(<span class="hljs-string">"concurrent map writes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))  <span class="hljs-comment">//1</span></span><br><span class="line"></span><br><span class="line">    h.flags ^= hashWriting     <span class="hljs-comment">//给falgs上标记</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> h.buckets == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="hljs-comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)   <span class="hljs-comment">//2</span></span><br><span class="line">    <span class="hljs-keyword">if</span> h.growing() &#123;</span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    b := (*bmap)(unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(h.buckets) + bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    top := tophash(hash)      <span class="hljs-comment">//取tophash</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> inserti *<span class="hljs-keyword">uint8</span></span><br><span class="line">    <span class="hljs-keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">    <span class="hljs-keyword">var</span> val unsafe.Pointer</span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="hljs-keyword">for</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;                        <span class="hljs-comment">/* 遍历桶中的8个key */</span></span><br><span class="line">            <span class="hljs-keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="hljs-literal">nil</span> &#123;        <span class="hljs-comment">//4.找到插入的位置</span></span><br><span class="line">                    inserti = &amp;b.tophash[i]</span><br><span class="line">                    insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">                    val = add(unsafe.Pointer(b),  dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;        </span><br><span class="line">                    <span class="hljs-keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line">                <span class="hljs-keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> t.needkeyupdate() &#123;      <span class="hljs-comment">//3.更新</span></span><br><span class="line">                typedmemmove(t.key, k, key)</span><br><span class="line">            &#125;</span><br><span class="line">            val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))</span><br><span class="line">            <span class="hljs-keyword">goto</span> done</span><br><span class="line">        &#125;</span><br><span class="line">        ovf := b.overflow(t)</span><br><span class="line">        <span class="hljs-keyword">if</span> ovf == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        b = ovf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="hljs-keyword">goto</span> again <span class="hljs-comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> inserti == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        newb := h.newoverflow(t, b)             <span class="hljs-comment">//5</span></span><br><span class="line">        inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]</span><br><span class="line">        insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">        val = add(insertk, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">        kmem := newobject(t.key)</span><br><span class="line">        *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">        insertk = kmem</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">        vmem := newobject(t.elem)</span><br><span class="line">        *(*unsafe.Pointer)(val) = vmem</span><br><span class="line">    &#125;</span><br><span class="line">    typedmemmove(t.key, insertk, key)</span><br><span class="line">    *inserti = top</span><br><span class="line">    h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;</span><br><span class="line">        throw(<span class="hljs-string">"concurrent map writes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.flags &amp;^= hashWriting</span><br><span class="line">    <span class="hljs-keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">        val = *((*unsafe.Pointer)(val))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>跟据key值算出哈希值。</li>
<li>取哈希值低位与hmap.B取模确定bucket位置。</li>
<li>取哈希值高位与hmap.B查找该key是否已经存在,如果存在则直接更新值。</li>
<li>如果未找到且剩下的空间为empty,则将新的键存到该位置</li>
<li>如果未找到且遍历完buckets,查看是否有溢出桶,若有则遍历溢出桶；如果没有溢出桶,则申请一个新的溢出桶存放该元素。</li>
</ol>
<h3 id="map删除过程"><a href="#map删除过程" class="headerlink" title="map删除过程"></a><strong>map删除过程</strong></h3><figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapdelete</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> raceenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		pc := funcPC(mapdelete)</span><br><span class="line">		racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">		raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">if</span> msanenabled &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">		msanread(key, t.key.size)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || h.count == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		<span class="hljs-keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">			t.key.alg.hash(key, <span class="hljs-number">0</span>) <span class="hljs-comment">// see issue 23734</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="hljs-keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting != <span class="hljs-number">0</span> &#123;</span><br><span class="line">		throw(<span class="hljs-string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	alg := t.key.alg</span><br><span class="line">	hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line">	<span class="hljs-comment">// in which case we have not actually done a write (delete).</span></span><br><span class="line">	h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="hljs-keyword">if</span> h.growing() &#123;</span><br><span class="line">		growWork(t, h, bucket)</span><br><span class="line">	&#125;</span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">	bOrig := b</span><br><span class="line">	top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line">	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="hljs-keyword">break</span> search</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">			k2 := k</span><br><span class="line">			<span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">if</span> !alg.equal(key, k2) &#123;</span><br><span class="line">				<span class="hljs-keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">			<span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(k) = <span class="hljs-literal">nil</span></span><br><span class="line">			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.key.kind&amp;kindNoPointers == <span class="hljs-number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(k, t.key.size)</span><br><span class="line">			&#125;</span><br><span class="line">			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))</span><br><span class="line">			<span class="hljs-keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(v) = <span class="hljs-literal">nil</span></span><br><span class="line">			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> t.elem.kind&amp;kindNoPointers == <span class="hljs-number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(v, t.elem.size)</span><br><span class="line">			&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(v, t.elem.size)</span><br><span class="line">			&#125;</span><br><span class="line">			b.tophash[i] = emptyOne</span><br><span class="line">			<span class="hljs-comment">// If the bucket now ends in a bunch of emptyOne states,</span></span><br><span class="line">			<span class="hljs-comment">// change those to emptyRest states.</span></span><br><span class="line">			<span class="hljs-comment">// It would be nice to make this a separate function, but</span></span><br><span class="line">			<span class="hljs-comment">// for loops are not currently inlineable.</span></span><br><span class="line">			<span class="hljs-keyword">if</span> i == bucketCnt<span class="hljs-number">-1</span> &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> b.overflow(t) != <span class="hljs-literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="hljs-number">0</span>] != emptyRest &#123;</span><br><span class="line">					<span class="hljs-keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">				<span class="hljs-keyword">if</span> b.tophash[i+<span class="hljs-number">1</span>] != emptyRest &#123;</span><br><span class="line">					<span class="hljs-keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="hljs-keyword">for</span> &#123;</span><br><span class="line">				b.tophash[i] = emptyRest</span><br><span class="line">				<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;</span><br><span class="line">					<span class="hljs-keyword">if</span> b == bOrig &#123;</span><br><span class="line">						<span class="hljs-keyword">break</span> <span class="hljs-comment">// beginning of initial bucket, we're done.</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="hljs-comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">					c := b</span><br><span class="line">					<span class="hljs-keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					i = bucketCnt - <span class="hljs-number">1</span></span><br><span class="line">				&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">					i--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="hljs-keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">					<span class="hljs-keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		notLast:</span><br><span class="line">			h.count--</span><br><span class="line">			<span class="hljs-keyword">break</span> search</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">if</span> h.flags&amp;hashWriting == <span class="hljs-number">0</span> &#123;</span><br><span class="line">		throw(<span class="hljs-string">"concurrent map writes"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希表的删除逻辑与写入逻辑非常相似,只是触发哈希的删除需要使用关键字,如果在删除期间遇到了哈希表的扩容,就会对即将操作的桶进行迁移,迁移结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<h3 id="map扩容原理"><a href="#map扩容原理" class="headerlink" title="map扩容原理"></a><strong>map扩容原理</strong></h3><h4 id="扩容的前提条件"><a href="#扩容的前提条件" class="headerlink" title="扩容的前提条件"></a><strong>扩容的前提条件</strong></h4><ol>
<li><strong>增量扩容</strong>:负载因子 &gt; 6.5时,也即平均每个bucket存储的键值对达到6.5个。</li>
</ol>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">overLoadFactor</span><span class="hljs-params">(count <span class="hljs-keyword">int</span>, B <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">	<span class="hljs-keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="hljs-keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>等量扩容</strong>:overflow数量 &gt; 2^15时,也即overflow数量超过32768时。</li>
</ol>
<figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="hljs-comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="hljs-comment">// if use was dense, then we'd have already triggered regular map growth.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tooManyOverflowBuckets</span><span class="hljs-params">(noverflow <span class="hljs-keyword">uint16</span>, B <span class="hljs-keyword">uint8</span>)</span> <span class="hljs-title">bool</span></span> &#123;</span><br><span class="line">	<span class="hljs-comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line">	<span class="hljs-comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line">	<span class="hljs-comment">// "too many" means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line">	<span class="hljs-comment">// See incrnoverflow for more details.</span></span><br><span class="line">	<span class="hljs-keyword">if</span> B &gt; <span class="hljs-number">15</span> &#123;</span><br><span class="line">		B = <span class="hljs-number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-comment">// The compiler doesn't see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line">	<span class="hljs-keyword">return</span> noverflow &gt;= <span class="hljs-keyword">uint16</span>(<span class="hljs-number">1</span>)&lt;&lt;(B&amp;<span class="hljs-number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hashGrow</span><span class="hljs-params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    bigger := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">if</span> !overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) &#123;    <span class="hljs-comment">/* 判断是2倍空间扩容还是等量空间扩容 */</span></span><br><span class="line">        bigger = <span class="hljs-number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow             <span class="hljs-comment">/* 等量空间扩容,bigger=0 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="hljs-literal">nil</span>)   <span class="hljs-comment">/* 分配桶空间 */</span></span><br><span class="line"></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)      <span class="hljs-comment">/* 将buckets和oldbuckets迭代标志置0 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.B += bigger                      <span class="hljs-comment">/* 增量扩容为h.B+1,等量扩容为h.B */</span></span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="hljs-number">0</span>                  <span class="hljs-comment">/* 搬迁状态为0表示未进行迁移 */</span></span><br><span class="line">    h.noverflow = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/* 当key/value不是指针时,用extramap中的指针存储溢出桶,而不用bmap中的        </span></span><br><span class="line"><span class="hljs-comment">         * overflow。overflow表示hmap结构buckets中的溢出桶,oldoverflow表示hmap中</span></span><br><span class="line"><span class="hljs-comment">         * oldbuckets中的溢出桶 ,nextoverflow预分配溢出桶空间 。</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &amp;&amp; h.extra.overflow != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> h.extra.oldoverflow != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="hljs-string">"oldoverflow is not nil"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="hljs-literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> h.extra == <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">             h.extra = <span class="hljs-built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map迁移原理"><a href="#map迁移原理" class="headerlink" title="map迁移原理"></a><strong>map迁移原理</strong></h3> <figure class="highlight go hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">evacuate</span><span class="hljs-params">(t *maptype, h *hmap, oldbucket <span class="hljs-keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">     b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))  <span class="hljs-comment">/* oldbucket为旧桶的索引 */</span></span><br><span class="line">     newbit := h.noldbuckets()                         <span class="hljs-comment">/* 与原来旧桶分配的容量相等 */</span></span><br><span class="line">     <span class="hljs-keyword">if</span> !evacuated(b) &#123; </span><br><span class="line">         <span class="hljs-keyword">var</span> xy [<span class="hljs-number">2</span>]evacDst   <span class="hljs-comment">/*xy 包含x和y的 (low and high)疏散目的地.*/</span></span><br><span class="line">         x := &amp;xy[<span class="hljs-number">0</span>]                                   <span class="hljs-comment">/* 等量扩容或2倍扩容的前一部分（X,和原来相等） */</span></span><br><span class="line">         x.b = (*bmap)(add(h.buckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">         x.k = add(unsafe.Pointer(x.b), dataOffset)    <span class="hljs-comment">/* key的地址 */</span></span><br><span class="line">         x.v = add(x.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))  <span class="hljs-comment">/* value得地址 */</span></span><br><span class="line"></span><br><span class="line">         <span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;             <span class="hljs-comment">//如果不是等量扩容</span></span><br><span class="line">             y := &amp;xy[<span class="hljs-number">1</span>]                               <span class="hljs-comment">/* 若为2倍扩容,需要后一部分,即增长的空间 */</span></span><br><span class="line">             y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))  <span class="hljs-comment">/* 后一部分桶的索引 */</span></span><br><span class="line">             y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">             y.v = add(y.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;              <span class="hljs-comment">/* 遍历最后一个bmap及溢出桶 */</span></span><br><span class="line">             k := add(unsafe.Pointer(b), dataOffset)      <span class="hljs-comment">/* key的地址 */</span></span><br><span class="line">             v := add(k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))    <span class="hljs-comment">/* value的地址 */</span></span><br><span class="line">             <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="hljs-number">1</span>, add(k, <span class="hljs-keyword">uintptr</span>(t.keysize)), add(v, <span class="hljs-keyword">uintptr</span>(t.valuesize)) &#123;  <span class="hljs-comment">/* 遍历桶中的元素 */</span></span><br><span class="line">                 top := b.tophash[i]                      <span class="hljs-comment">/* 获取tophash的值 */</span></span><br><span class="line">                 <span class="hljs-keyword">if</span> isEmpty(top) &#123;                        <span class="hljs-comment">/* 如果tophash为空,标记为已被搬迁状态 */</span></span><br><span class="line">                     b.tophash[i] = evacuatedEmpty  </span><br><span class="line">                     <span class="hljs-keyword">continue</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="hljs-keyword">if</span> top &lt; minTopHash &#123;                    <span class="hljs-comment">/* tophash的值为hash+minTopHash */</span></span><br><span class="line">                     throw(<span class="hljs-string">"bad map state"</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">                 k2 := k</span><br><span class="line">                 <span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                     k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="hljs-keyword">var</span> useY <span class="hljs-keyword">uint8</span>                          <span class="hljs-comment">/* useY用来判断是落在oldbucket还是newbit */</span></span><br><span class="line">                 <span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;                  <span class="hljs-comment">/* 如果为2倍扩容,h.B增大1,桶的位置发生变化 */</span></span><br><span class="line">                     hash := t.key.alg.hash(k2, <span class="hljs-keyword">uintptr</span>(h.hash0))</span><br><span class="line">                     <span class="hljs-keyword">if</span> h.flags&amp;iterator != <span class="hljs-number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.alg.equal(k2,k2) &#123;</span><br><span class="line">                         useY = top &amp; <span class="hljs-number">1</span></span><br><span class="line">                         top = tophash(hash)</span><br><span class="line">                     &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                         <span class="hljs-keyword">if</span> hash&amp;newbit != <span class="hljs-number">0</span> &#123;</span><br><span class="line">                             useY = <span class="hljs-number">1</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="hljs-comment">/* evacuatedY = evacuatedX + 1 */</span></span><br><span class="line">                 <span class="hljs-keyword">if</span> evacuatedX+<span class="hljs-number">1</span> != evacuatedY || evacuatedX^<span class="hljs-number">1</span> != evacuatedY &#123;</span><br><span class="line">                     throw(<span class="hljs-string">"bad evacuatedN"</span>)</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 b.tophash[i] = evacuatedX + useY  <span class="hljs-comment">/* 搬迁为X或者Y状态 */</span></span><br><span class="line">                 dst := &amp;xy[useY]                  <span class="hljs-comment">/* useY=0表示搬迁到前半部分, 否则到后半部分*/</span></span><br><span class="line"></span><br><span class="line">                 <span class="hljs-keyword">if</span> dst.i == bucketCnt &#123;           <span class="hljs-comment">/* 当桶中元素数量达到最大8时,需要溢出桶 */</span></span><br><span class="line">                     dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                     dst.i = <span class="hljs-number">0</span></span><br><span class="line">                     dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                     dst.v = add(dst.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">                 &#125;</span><br><span class="line">                 dst.b.tophash[dst.i&amp;(bucketCnt<span class="hljs-number">-1</span>)] = top</span><br><span class="line">                 <span class="hljs-keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                     *(*unsafe.Pointer)(dst.k) = k2   <span class="hljs-comment">/* key为指针时,复制指针 */</span></span><br><span class="line">                 &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                     typedmemmove(t.key, dst.k, k)</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="hljs-keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">                     *(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v) <span class="hljs-comment">/* value为指针时,复制指针 */</span></span><br><span class="line">                 &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                     typedmemmove(t.elem, dst.v, v)</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="hljs-comment">/* 进行下一个元素的搬迁 */</span></span><br><span class="line">                 dst.i++</span><br><span class="line">                 dst.k = add(dst.k, <span class="hljs-keyword">uintptr</span>(t.keysize))</span><br><span class="line">                 dst.v = add(dst.v, <span class="hljs-keyword">uintptr</span>(t.valuesize))</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="hljs-comment">/* 遍历完桶后,如果没有其他goroutine使用该桶,就把该桶清空 */</span></span><br><span class="line">         <span class="hljs-keyword">if</span> h.flags&amp;oldIterator == <span class="hljs-number">0</span> &amp;&amp; t.bucket.kind&amp;kindNoPointers == <span class="hljs-number">0</span> &#123;</span><br><span class="line">             b := add(h.oldbuckets, oldbucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize))</span><br><span class="line">             ptr := add(b, dataOffset)</span><br><span class="line">             n := <span class="hljs-keyword">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">             memclrHasPointers(ptr, n)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="hljs-keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">         advanceEvacuationMark(h, t, newbit)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">/* 确定桶的搬迁进度,如果搬迁完成进行后续操作 */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">advanceEvacuationMark</span><span class="hljs-params">(h *hmap, t *maptype, newbit <span class="hljs-keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">     h.nevacuate++</span><br><span class="line">     stop := h.nevacuate + <span class="hljs-number">1024</span></span><br><span class="line">     <span class="hljs-keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">         stop = newbit</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;  <span class="hljs-comment">/*如果搬迁没有完成将搬迁进度nevacuate加1 */</span></span><br><span class="line">         h.nevacuate++</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">         h.oldbuckets = <span class="hljs-literal">nil</span>                <span class="hljs-comment">/* 搬迁完成,将oldbuckets置nil */</span></span><br><span class="line">         <span class="hljs-keyword">if</span> h.extra != <span class="hljs-literal">nil</span> &#123;</span><br><span class="line">             h.extra.oldoverflow = <span class="hljs-literal">nil</span>     <span class="hljs-comment">/* 溢出桶置为nil */</span></span><br><span class="line">         &#125;</span><br><span class="line">         h.flags &amp;^= sameSizeGrow          <span class="hljs-comment">/* 等量扩容位置0 */</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/Golang%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">Golang源码分析</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="//md.ulovecode.com/static/images/avatar/alipay_v1.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="//md.ulovecode.com/static/images/avatar/wechatpay_v1.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2020/03/02/Go/%E5%BE%97%E5%88%B0Golang%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%20/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">得到 Golang 程序的汇编代码的方法</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2020/02/27/Linux/%E4%BD%BF%E7%94%A8Git%E4%BB%A3%E7%90%86%E4%B8%BAGithub%E6%8F%90%E9%80%9F/">
                <span class="level-item">使用 Git 代理为 Github 提速</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
    <div id="comment-container"></div>
`    <link rel="stylesheet" href="https://code.bdstatic.com/npm/gitalk@1.7.2/dist/gitalk.css">
    <script src="https://code.bdstatic.com/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
            clientID: 'ceb3f7e3fadb589ca8f2',
            clientSecret: 'ab52c871230e4d10ee2c2b54a8f9681727302b4d',
            id: '9667af7c320735bbb9560028af9ec1dd',
            repo: 'ulovecode.github.io',
            owner: 'ulovecode',
            admin: "ulovecode",
        })
        gitalk.render('comment-container')
    </script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="https://md.ulovecode.com/static/images/avatar/avatar_v1.jpg?imageView2/0/w/460/h/460" alt="Jovan">
                    
                    
                    <p class="is-size-4 is-block">
                        Jovan
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Keep moving.Don&#39;t settle.
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Shanghai，China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        52
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        14
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        27
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/ulovecode" target="_blank">
                follow</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/ulovecode">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                目录
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#一、切片">
        <span class="has-mr-6">1</span>
        <span>一、切片</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#Slice数据结构">
        <span class="has-mr-6">1.1</span>
        <span>Slice数据结构</span>
        </a></li><li>
        <a class="is-flex" href="#slice的三种初始化方式">
        <span class="has-mr-6">1.2</span>
        <span>slice的三种初始化方式</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#make初始化">
        <span class="has-mr-6">1.2.1</span>
        <span>make初始化</span>
        </a></li><li>
        <a class="is-flex" href="#struct">
        <span class="has-mr-6">1.2.2</span>
        <span>[]struct{}{}</span>
        </a></li><li>
        <a class="is-flex" href="#new-struct">
        <span class="has-mr-6">1.2.3</span>
        <span>new([]struct{})</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#slice的扩容机制">
        <span class="has-mr-6">1.3</span>
        <span>slice的扩容机制</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#使用append-方法的扩容">
        <span class="has-mr-6">1.3.1</span>
        <span>使用append()方法的扩容:</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#slice的复制">
        <span class="has-mr-6">1.4</span>
        <span>slice的复制</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#使用copy-进行复制">
        <span class="has-mr-6">1.4.1</span>
        <span>使用copy()进行复制</span>
        </a></li><li>
        <a class="is-flex" href="#使用slice-start-end-方法进行复制">
        <span class="has-mr-6">1.4.2</span>
        <span>使用slice[start:end]方法进行复制</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#二、channel">
        <span class="has-mr-6">2</span>
        <span>二、channel</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#chan数据结构">
        <span class="has-mr-6">2.1</span>
        <span>chan数据结构</span>
        </a></li><li>
        <a class="is-flex" href="#创建channel">
        <span class="has-mr-6">2.2</span>
        <span>创建channel</span>
        </a></li><li>
        <a class="is-flex" href="#向channel写数据">
        <span class="has-mr-6">2.3</span>
        <span>向channel写数据</span>
        </a></li><li>
        <a class="is-flex" href="#从channel读数据">
        <span class="has-mr-6">2.4</span>
        <span>从channel读数据</span>
        </a></li><li>
        <a class="is-flex" href="#关闭channel">
        <span class="has-mr-6">2.5</span>
        <span>关闭channel</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#三、map">
        <span class="has-mr-6">3</span>
        <span>三、map</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#map数据结构">
        <span class="has-mr-6">3.1</span>
        <span>map数据结构</span>
        </a></li><li>
        <a class="is-flex" href="#平衡因子选取">
        <span class="has-mr-6">3.2</span>
        <span>平衡因子选取</span>
        </a></li><li>
        <a class="is-flex" href="#冲突解决">
        <span class="has-mr-6">3.3</span>
        <span>冲突解决</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#map使用了拉链法">
        <span class="has-mr-6">3.3.1</span>
        <span>map使用了拉链法</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#map创建">
        <span class="has-mr-6">3.4</span>
        <span>map创建</span>
        </a></li><li>
        <a class="is-flex" href="#map查找过程">
        <span class="has-mr-6">3.5</span>
        <span>map查找过程</span>
        </a></li><li>
        <a class="is-flex" href="#map插入过程">
        <span class="has-mr-6">3.6</span>
        <span>map插入过程</span>
        </a></li><li>
        <a class="is-flex" href="#map删除过程">
        <span class="has-mr-6">3.7</span>
        <span>map删除过程</span>
        </a></li><li>
        <a class="is-flex" href="#map扩容原理">
        <span class="has-mr-6">3.8</span>
        <span>map扩容原理</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#扩容的前提条件">
        <span class="has-mr-6">3.8.1</span>
        <span>扩容的前提条件</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#map迁移原理">
        <span class="has-mr-6">3.9</span>
        <span>map迁移原理</span>
        </a></li></ul></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
<!--                <a class="footer-logo is-block has-mb-6" href="/">-->
<!--                -->
<!--                    <img src="//md.ulovecode.com/static/images/avatar/logo.jpg" alt="Go源码分析(5) - 数据结构" height="28">-->
<!--                -->
<!--                </a>-->
<!--                <p class="is-size-7">-->
<!--                &copy; 2023 Jovan&nbsp;-->
<!--                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a-->
<!--                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>-->
<!--                -->
<!--                </p>-->
                <p class="is-size-7">
                    
                </p>
            </div>
<!--    备案号信息        -->
            <center>
            <a href="http://www.beian.miit.gov.cn/" target="_blank" style="color: rgba(0,0,0,0.65)"  noopenerrel="" > 鄂ICP备17027965号-1</a>
            </center>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://code.bdstatic.com/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://code.bdstatic.com/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    
    
    <script src="https://code.bdstatic.com/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://code.bdstatic.com/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="https://md.ulovecode.com/static/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://code.bdstatic.com/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="https://md.ulovecode.com/static/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://code.bdstatic.com/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="https://md.ulovecode.com/static/js/clipboard.js" defer></script>
    

    
    
    


<script src="https://md.ulovecode.com/static/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: 'https://md.ulovecode.com/static/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="https://md.ulovecode.com/static/js/insight.js" defer></script>
<link rel="stylesheet" href="https://md.ulovecode.com/static/css/search.css">
<link rel="stylesheet" href="https://md.ulovecode.com/static/css/insight.css">
    
</body>
</html>