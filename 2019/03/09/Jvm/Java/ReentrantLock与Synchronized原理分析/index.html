<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<meta name="referrer" content="no-referrer">
<title>ReentrantLock 与 Synchronized 原理分析 - Jovan&#39;s Blog</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>




    <meta name="description" content="ReentrantLock,可重入锁,是一种递归无阻塞的同步机制。它可以等同于 synchronized 的使用,但是 ReentrantLock 提供了比 synchronized 更强大、灵活的锁机制,可以减少死锁发生的概率。 synchronized 是 Java 中的关键字,是利用锁的机制来实现同步的。">
<meta property="og:type" content="article">
<meta property="og:title" content="ReentrantLock 与 Synchronized 原理分析">
<meta property="og:url" content="https://www.ulovecode.com/2019/03/09/Jvm/Java/ReentrantLock%E4%B8%8ESynchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Jovan&#39;s Blog">
<meta property="og:description" content="ReentrantLock,可重入锁,是一种递归无阻塞的同步机制。它可以等同于 synchronized 的使用,但是 ReentrantLock 提供了比 synchronized 更强大、灵活的锁机制,可以减少死锁发生的概率。 synchronized 是 Java 中的关键字,是利用锁的机制来实现同步的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://md.ulovecode.com/static/images/posts/f352bcba1d7faf2e806c90e2a49e7aae.jpg">
<meta property="article:published_time" content="2019-03-09T15:53:00.000Z">
<meta property="article:modified_time" content="2019-03-09T15:53:00.000Z">
<meta property="article:author" content="Jovan">
<meta property="article:tag" content="原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://md.ulovecode.com/static/images/posts/f352bcba1d7faf2e806c90e2a49e7aae.jpg">







    <link rel="icon" href="//md.ulovecode.com/static/images/avatar/logo.jpg">

<link rel="stylesheet" href="https://code.bdstatic.com/npm/bulma@0.7.5/css/bulma.min.css">
<link rel="stylesheet" href="https://s3.pstatp.com/cdn/expire-1-M/font-awesome/5.8.1/css/all.min.css">
<!--<link rel="stylesheet" href="https://fonts.proxy.ustclug.org/css?family=Noto+Serif+SC:500|Source+Code+Pro:500&display=swap">-->

 <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.6.0/style.css" />
 
<!-- <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/lxgwwenkaiscreen.css"> -->

<link rel="stylesheet" href="https://code.bdstatic.com/npm/highlight.js@10.1.0/styles/github.css">


    
        
    
        
    
    <link rel="stylesheet" href="https://code.bdstatic.com/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://code.bdstatic.com/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
        

<link rel="stylesheet" href="https://code.bdstatic.com/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
        
    
        

<link rel="stylesheet" href="https://md.ulovecode.com/static/css/back-to-top.css">


    
        

    
        
    
        

    
        
    
        
    

    
        
    


<link rel="stylesheet" href="https://md.ulovecode.com/static/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="//md.ulovecode.com/static/images/avatar/logo.jpg" alt="ReentrantLock 与 Synchronized 原理分析" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">主页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/ulovecode">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="//md.ulovecode.com/static/images/posts/f352bcba1d7faf2e806c90e2a49e7aae.jpg" alt="ReentrantLock 与 Synchronized 原理分析">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-09T15:53:00.000Z">2019-03-09</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Java/">Java</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    42 分钟 读完 (大约 6255 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                ReentrantLock 与 Synchronized 原理分析
            
        </h1>
        <div class="content">
            <p>ReentrantLock,可重入锁,是一种递归无阻塞的同步机制。它可以等同于 synchronized 的使用,但是 ReentrantLock 提供了比 synchronized 更强大、灵活的锁机制,可以减少死锁发生的概率。</p>
<p>synchronized 是 Java 中的关键字,是利用锁的机制来实现同步的。</p>
<a id="more"></a>
<hr>
<h1 id="一、synchronized"><a href="#一、synchronized" class="headerlink" title="一、synchronized"></a>一、synchronized</h1><p>synchronized 是 Java 中的关键字,是利用锁的机制来实现同步的。<br>锁机制有如下两种特性：</p>
<p>互斥性：即在同一时间只允许一个线程持有某个对象锁,通过这种特性来实现多线程中的协调机制,这样在同一时间只有一个线程对需同步的代码块(复合操作)进行访问。互斥性我们也往往称为操作的原子性。</p>
<p>可见性：必须确保在锁被释放之前,对共享变量所做的修改,对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值）,否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。</p>
<h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1. 实现原理"></a>1. 实现原理</h2><blockquote>
<p><code>synchronized</code>可以保证方法或者代码块在运行时,同一时刻只有一个方法可以进入到临界区,同时它还可以保证共享变量的内存可见性。</p>
</blockquote>
<p>Java 中每一个对象都可以作为锁,这是 synchronized 实现同步的基础：</p>
<ol>
<li>普通同步方法,锁是当前实例对象</li>
<li>静态同步方法,锁是当前类的 class 对象</li>
<li>同步方法块,锁是括号里面的对象</li>
</ol>
<blockquote>
<p>通过javap工具生成对class文件信息来分析synchronized</p>
</blockquote>
<figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">monitorenter</span> </span><br><span class="line"><span class="hljs-attribute">aload_i</span></span><br><span class="line"><span class="hljs-attribute">monitorexit</span></span><br></pre></td></tr></table></figure>
<ol>
<li>同步代码块是使用 monitorenter 和 monitorexit 指令实现的；</li>
<li>同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED 实现。</li>
</ol>
<p>同步代码块：monitorenter 指令插入到同步代码块的开始位置,monitorexit 指令插入到同步代码块的结束位置,JVM 需要保证每一个 monitorenter 都有一个 monitorexit 与之相对应。任何对象都有一个 Monitor 与之相关联,当且一个 Monitor 被持有之后,他将处于锁定状态。线程执行到 monitorenter 指令时,将会尝试获取对象所对应的 Monitor 所有权,即尝试获取对象的锁。</p>
<p>同步方法：synchronized 方法则会被翻译成普通的方法调用和返回指令如：invokevirtual、areturn 指令,在 VM 字节码层面并没有任何特别的指令来实现被synchronized 修饰的方法,而是在 Class 文件的方法表中将该方法的 access_flags 字段中的 synchronized 标志位置设置为 1,表示该方法是同步方法,并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象</p>
<blockquote>
<p>ReentrantLock的底层是借助AbstractQueuedSynchronizer实现,所以其数据结构依附于AbstractQueuedSynchronizer的数据结构</p>
</blockquote>
<h2 id="2-Java-对象头、Monitor"><a href="#2-Java-对象头、Monitor" class="headerlink" title="2.Java 对象头、Monitor"></a>2.Java 对象头、Monitor</h2><p>Java 对象头和 Monitor 是实现 synchronized 的基础！下面就这两个概念来做详细介绍。</p>
<h3 id="2-1-Java对象头"><a href="#2-1-Java对象头" class="headerlink" title="2.1 Java对象头"></a>2.1 Java对象头</h3><p><code>synchronized</code>用的锁是存在Java对象头里的。那么什么是 Java 对象头呢？Hotspot 虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中：</p>
<ul>
<li>Klass Point 是是对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
<li>Mark Word 用于存储对象自身的运行时数据,它是实现轻量级锁和偏向锁的关键</li>
</ul>
<blockquote>
<p>Mark Word 用于存储对象自身的运行时数据,如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java 对象头一般占有两个机器码（在 32 位虚拟机中,1 个机器码等于 4 字节,也就是 32 bits）。但是如果对象是数组类型,则需要三个机器码,因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小,无法从数组的元数据来确认数组的大小,所以用一块来记录数组长度。</p>
</blockquote>
<h3 id="2-2-Monitor"><a href="#2-2-Monitor" class="headerlink" title="2.2 Monitor"></a>2.2 Monitor</h3><p>我们可以把它理解为一个同步工具,也可以描述为一种同步机制,它通常被描述为一个对象。每一个 Java 对象本身就带了一把看不见的锁,它叫做内部锁或者 Monitor 锁。</p>
<blockquote>
<ul>
<li>互斥： 一个 Monitor 锁在同一时刻只能被一个线程占用,其他线程无法占用。</li>
<li>信号机制( signal )： 占用 Monitor 锁失败的线程会暂时放弃竞争并等待某个谓词成真（条件变量）,但该条件成立后,当前线程会通过释放锁通知正在等待这个条件变量的其他线程,让其可以重新竞争锁。</li>
</ul>
</blockquote>
<p>Monitor Record 是线程私有的数据结构,每一个线程都有一个可用 Monitor Record 列表,同时还有一个全局的可用列表。<br>每一个被锁住的对象都会和一个 Monitor Record 关联（对象头的 MarkWord 中的 LockWord 指向 Monitor 的起始地址）,Monitor Record 中有一个 Owner 字段,存放拥有该锁的线程的唯一标识,表示该锁被这个线程占用。其结构如下：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Owner</span><br><span class="line">EntryQ</span><br><span class="line">RcThis</span><br><span class="line">Nest</span><br><span class="line">HashCode</span><br><span class="line">Candidate</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Owner：</p>
<ol>
<li>初始时为 NULL 表示当前没有任何线程拥有该 Monitor Record。</li>
<li>当线程成功拥有该锁后保存线程唯一标识。</li>
<li>当锁被释放时又设置为 NULL 。</li>
</ol>
</li>
<li><p>EntryQ：关联一个系统互斥锁（ semaphore ）,阻塞所有试图锁住 Monitor Record失败的线程 。</p>
</li>
<li>RcThis：表示 blocked 或 waiting 在该 Monitor Record 上的所有线程的个数。</li>
<li>Nest：用来实现重入锁的计数。</li>
<li>HashCode：保存从对象头拷贝过来的 HashCode 值（可能还包含 GC age ）。</li>
<li>Candidate：用来避免不必要的阻塞或等待线程唤醒。因为每一次只有一个线程能够成功拥有锁,如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程,会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate 只有两种可能的值 ：1）0 表示没有需要唤醒的线程；2）1 表示要唤醒一个继任线程来竞争锁。</li>
</ol>
<h2 id="3-锁优化"><a href="#3-锁优化" class="headerlink" title="3. 锁优化"></a>3. 锁优化</h2><h3 id="3-1-自旋锁"><a href="#3-1-自旋锁" class="headerlink" title="3.1 自旋锁"></a>3.1 自旋锁</h3><p><strong>由来</strong></p>
<blockquote>
<p>线程的阻塞和唤醒,需要 CPU 从用户态转为核心态。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作,势必会给系统的并发性能带来很大的压力。同时,我们发现在许多应用上面,对象锁的锁状态只会持续很短一段时间。为了这一段很短的时间,频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p>
</blockquote>
<p><strong>定义</strong></p>
<blockquote>
<p>所谓自旋锁,就是让该线程等待一段时间,不会被立即挂起,看持有锁的线程是否会很快释放锁。</p>
</blockquote>
<p>怎么等待呢？执行一段无意义的循环即可（自旋）。</p>
<h4 id="3-1-1-适应自旋锁"><a href="#3-1-1-适应自旋锁" class="headerlink" title="3.1.1 适应自旋锁"></a>3.1.1 适应自旋锁</h4><p>JDK 1.6 引入了更加聪明的自旋锁,即自适应自旋锁。</p>
<p>所谓自适应就意味着自旋的次数不再是固定的,它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？</p>
<blockquote>
<p>线程如果自旋成功了,那么下次自旋的次数会更加多,因为虚拟机认为既然上次成功了,那么此次自旋也很有可能会再次成功,那么它就会允许自旋等待持续的次数更多。<br>反之,如果对于某个锁,很少有自旋能够成功的,那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程,以免浪费处理器资源。<br>有了自适应自旋锁,随着程序运行和性能监控信息的不断完善,虚拟机对程序锁的状况预测会越来越准确,虚拟机会变得越来越聪明。</p>
</blockquote>
<h3 id="3-2-锁消除"><a href="#3-2-锁消除" class="headerlink" title="3.2 锁消除"></a>3.2 锁消除</h3><p><strong>由来</strong></p>
<blockquote>
<p>为了保证数据的完整性,我们在进行操作时需要对这部分操作进行同步控制。但是,在有些情况下,JVM检测到不可能存在共享数据竞争,这是JVM会对这些同步锁进行锁消除。如果不存在竞争,为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。</p>
</blockquote>
<p><strong>定义</strong></p>
<blockquote>
<p>锁消除的依据是<strong>逃逸分析的数据支持</strong>。变量是否逃逸,对于虚拟机来说需要使用数据流分析来确定,但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁,但是我们在使用一些 JDK 的内置 API 时,如 StringBuffer、Vector、HashTable 等,这个时候会存在<strong>隐性的加锁操作</strong>。比如 StringBuffer 的<code>append(..)</code>方法,Vector 的<code>add(...)</code></p>
</blockquote>
<h3 id="3-3-锁粗化"><a href="#3-3-锁粗化" class="headerlink" title="3.3 锁粗化"></a>3.3 锁粗化</h3><p><strong>由来</strong></p>
<blockquote>
<p>我们知道在使用同步锁的时候,需要让同步块的作用范围尽可能小：仅在共享数据的实际作用域中才进行同步。这样做的目的,是为了使需要同步的操作数量尽可能缩小,如果存在锁竞争,那么等待锁的线程也能尽快拿到锁。</p>
</blockquote>
<p>在大多数的情况下,上述观点是正确的,但是如果一系列的连续加锁解锁操作,可能会导致不必要的性能损耗,所以引入锁粗话的概念。</p>
<p><strong>定义</strong></p>
<blockquote>
<p>锁粗话概念比较好理解,就是将多个连续的加锁、解锁操作连接在一起,扩展成一个范围更大的锁。</p>
</blockquote>
<p>如下面实例：vector 每次 add 的时候都需要加锁操作,JVM 检测到对同一个对象（vector）连续加锁、解锁操作,会合并一个更大范围的加锁、解锁操作,即加锁解锁操作会移到 for 循环之外。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vectorTest</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i++)&#123;</span><br><span class="line">    	vector.add(i + <span class="hljs-string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-锁的升级"><a href="#3-4-锁的升级" class="headerlink" title="3.4 锁的升级"></a>3.4 锁的升级</h3><blockquote>
<p>锁主要存在四种状态,依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。它们会随着竞争的激烈而逐渐升级。注意,锁可以升级不可降级,这种策略是为了提高获得锁和释放锁的效率。</p>
</blockquote>
<h4 id="3-4-1-重量级锁"><a href="#3-4-1-重量级锁" class="headerlink" title="3.4.1 重量级锁"></a>3.4.1 重量级锁</h4><p>重量级锁通过对象内部的监视器（Monitor）实现。</p>
<blockquote>
<p>其中,Monitor 的本质是,依赖于底层操作系统的 Mutex Lock 实现。操作系统实现线程之间的切换,需要从用户态到内核态的切换,切换成本非常高。</p>
</blockquote>
<h4 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h4><blockquote>
<p>引入轻量级锁的主要目的,是在没有多线程竞争的前提下,减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
</blockquote>
<p>当关闭偏向锁功能或者多个线程竞争偏向锁,导致偏向锁升级为轻量级锁,则会尝试获取轻量级锁,其步骤如下：</p>
<p><strong>获取锁</strong></p>
<ol>
<li>判断当前对象是否处于无锁状态？<ul>
<li>若是,则 JVM 首先将在当前线程的栈帧中,建立一个名为锁记录（Lock Record）的空间,用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀,即 Displaced Mark Word）</li>
<li>否则,执行步骤（3）；</li>
</ul>
</li>
<li>JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正<ul>
<li>如果成功,表示竞争到锁,则将锁标志位变成 00（表示此对象处于轻量级锁状态）,执行同步操作</li>
<li>如果失败,则执行步骤（3）；</li>
</ul>
</li>
<li>判断当前对象的 Mark Word 是否指向当前线程的栈帧？<ul>
<li>如果是,则表示当前线程已经持有当前对象的锁,则直接执行同步代码块；</li>
<li>否则,只能说明该锁对象已经被其他线程抢占了,当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁,此时轻量级锁会升级为重量级锁,锁标志位变成 10,当前线程会被阻塞。</li>
</ul>
</li>
</ol>
<p><strong>释放锁</strong></p>
<blockquote>
<p>轻量级锁的释放也是通过 CAS 操作来进行的,主要步骤如下：</p>
</blockquote>
<ol>
<li>取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。</li>
<li>使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果成功,则说明释放锁成功；否则,执行（3）。</li>
<li>如果 CAS 操作替换失败,说明有其他线程尝试获取该锁,则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<blockquote>
<p>对于轻量级锁,其性能提升的依据是：“对于绝大部分的锁,在整个生命周期内都是不会存在竞争的”。如果打破这个依据则除了互斥的开销外,还有额外的 CAS 操作,因此在有多线程竞争的情况下,轻量级锁比重量级锁更慢。</p>
</blockquote>
<h4 id="3-4-3-偏向锁"><a href="#3-4-3-偏向锁" class="headerlink" title="3.4.3 偏向锁"></a>3.4.3 偏向锁</h4><blockquote>
<p>引入偏向锁主要目的是：为了在无多线程竞争的情况下,尽量减少不必要的轻量级锁执行路径。</p>
</blockquote>
<p>上面提到了轻量级锁的加锁解锁操作,是需要依赖多次 CAS 原子指令的。那么偏向锁是如何来减少不必要的 CAS 操作呢？我们可以查看 Mark Word 的数据结构就明白了。</p>
<blockquote>
<p>偏向锁时 Mark Word 的数据结构为：线程 ID、Epoch( 偏向锁的时间戳 )、对象分带年龄、是否是偏向锁( 1 )、锁标识位( 01 )</p>
</blockquote>
<p>只需要检查是否为偏向锁、锁标识为以及 ThreadID 即可,处理流程如下：</p>
<p><strong>获取偏向锁</strong></p>
<ol>
<li>检测 Mark Word是 否为可偏向状态,即是否为偏向锁的标识位为 1 ,锁标识位为 01 。</li>
<li>若为可偏向状态,则测试线程 ID 是否为当前线程 ID ?<ul>
<li>如果是,则执行步骤（5）</li>
<li>否则,执行步骤（3）。</li>
</ul>
</li>
<li>如果线程 ID 不为当前线程 ID ,则通过 CAS 操作竞争锁。<ul>
<li>竞争成功,则将 Mark Word 的线程 ID 替换为当前线程 ID ,则执行步骤（5）</li>
<li>否则,执行线程（4）。</li>
</ul>
</li>
<li>通过 CAS 竞争锁失败,证明当前存在多线程竞争情况,当到达全局安全点,获得偏向锁的线程被挂起,偏向锁升级为轻量级锁,然后被阻塞在安全点的线程继续往下执行同步代码块。</li>
<li>执行同步代码块</li>
</ol>
<p><strong>撤销偏向锁</strong></p>
<p><strong>偏向锁的释放采用了一种只有竞争才会释放锁的机制</strong>,线程是不会主动去释放偏向锁,需要等待其他线程来竞争。</p>
<p>偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程,判断锁对象是否还处于被锁定状态。</li>
<li>撤销偏向锁,恢复到无锁状态（ 01 ）或者轻量级锁的状态。</li>
<li>最后唤醒暂停的线程。</li>
</ol>
<p><strong>关闭偏向锁</strong></p>
<p>偏向锁在 JDK 1.6 以上,默认开启。开启后程序启动几秒后才会被激活,可使用 JVM 参数<code>-XX：BiasedLockingStartupDelay = 0</code>来关闭延迟。</p>
<p>如果确定锁通常处于竞争状态,则可通过JVM参数<code>-XX:-UseBiasedLocking=false</code>关闭偏向锁,那么默认会进入轻量级锁。</p>
<hr>
<h1 id="二、ReentrantLock"><a href="#二、ReentrantLock" class="headerlink" title="二、ReentrantLock"></a>二、ReentrantLock</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote>
<p>一个可重入的互斥锁定 Lock,它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义,但功能更强大。ReentrantLock 将由最近成功获得锁定,并且还没有释放该锁定的线程所拥有。当锁定没有被另一个线程所拥有时,调用 lock 的线程将成功获取该锁定并返回。如果当前线程已经拥有该锁定,此方法将立即返回。可以使用<code>isHeldByCurrentThread()</code>和<code>getHoldCount()</code>方法来检查此情况是否发生。</p>
</blockquote>
<p>ReentrantLock 还提供了公平锁和非公平锁的选择,通过构造方法接受一个可选的 fair 参数（默认非公平锁）：当设置为 true 时,表示公平锁；否则为非公平锁。</p>
<blockquote>
<p>公平锁与非公平锁的区别在于,公平锁的锁获取是有顺序的。但是公平锁的效率往往没有非公平锁的效率高,在许多线程访问的情况下,公平锁表现出较低的吞吐量。</p>
</blockquote>
<p>ReentrantLock 整体结构:</p>
<ul>
<li>ReentrantLock 实现 Lock 接口,基于内部的 Sync 实现。</li>
<li>Sync 实现 AQS ,提供了 FairSync 和 NonFairSync 两种实现。</li>
</ul>
<h2 id="2-Sync-抽象类"><a href="#2-Sync-抽象类" class="headerlink" title="2. Sync 抽象类"></a>2. Sync 抽象类</h2><blockquote>
<p>Sync 是 ReentrantLock 的内部静态类,实现 AbstractQueuedSynchronizer 抽象类,同步器抽象类。它使用 AQS 的 state 字段,来表示当前锁的持有数量,从而实现可重入的特性。</p>
</blockquote>
<h3 id="2-1-lock"><a href="#2-1-lock" class="headerlink" title="2.1 lock"></a>2.1 lock</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs &#123;<span class="hljs-doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="hljs-comment"> * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行锁。抽象了该方法的原因是,允许子类实现快速获得非公平锁的逻辑。</p>
<h3 id="2-2-nonfairTryAcquire"><a href="#2-2-nonfairTryAcquire" class="headerlink" title="2.2 nonfairTryAcquire"></a>2.2 nonfairTryAcquire</h3><p><code>nonfairTryAcquire(int acquires)</code>方法,非公平锁的方式获得锁。代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//当前线程</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="hljs-comment">//获取同步状态</span></span><br><span class="line">    <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">    <span class="hljs-comment">//state == 0,表示没有该锁处于空闲状态</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//获取锁成功,设置为当前线程所有</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//线程重入</span></span><br><span class="line">    <span class="hljs-comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span></span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要逻辑：首先判断同步状态 state == 0 ?</p>
<ul>
<li>如果是,表示该锁还没有被线程持有,直接通过CAS获取同步状态。<ul>
<li>如果成功,返回 true 。</li>
<li>否则,返回 false 。</li>
</ul>
</li>
<li>如果不是,则判断当前线程是否为获取锁的线程？<ul>
<li>如果是,则获取锁,成功返回 true 。成功获取锁的线程,再次获取锁,这是增加了同步状态 state 。通过这里的实现,我们可以看到上面提到的 “它使用 AQS 的 state 字段,来表示当前锁的持有数量,从而实现可重入的特性”。</li>
<li>否则,返回 false 。</li>
</ul>
</li>
</ul>
<blockquote>
<p>理论来说,这个方法应该在子类 FairSync 中实现,但是为什么会在这里呢？在下文的 ReentrantLock.tryLock() 中,详细解析。</p>
</blockquote>
<h3 id="2-3-tryRelease"><a href="#2-3-tryRelease" class="headerlink" title="2.3 tryRelease"></a>2.3 tryRelease</h3><p><code>tryRelease(int releases)</code>实现方法,释放锁。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 减掉releases</span></span><br><span class="line">    <span class="hljs-keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="hljs-comment">// 如果释放的不是持有锁的线程,抛出异常</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-comment">// state == 0 表示已经释放完全了,其他线程可以获取同步状态了</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        free = <span class="hljs-keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="hljs-keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过判断判断是否为获得到锁的线程,保证该方法线程安全。</li>
<li>只有当同步状态彻底释放后,该方法才会返回 true 。当<code>state == 0</code>时,则将锁持有线程设置为 null ,<code>free = true</code>,表示释放成功。</li>
</ul>
<blockquote>
<p>从这些方法中,我们可以看到,ReentrantLock 是独占获取同步状态的模式。</p>
</blockquote>
<h2 id="3-Sync-实现类"><a href="#3-Sync-实现类" class="headerlink" title="3. Sync 实现类"></a>3. Sync 实现类</h2><h3 id="3-1-NonfairSync"><a href="#3-1-NonfairSync" class="headerlink" title="3.1 NonfairSync"></a>3.1 NonfairSync</h3><blockquote>
<p>NonfairSync 是 ReentrantLock 的内部静态类,实现 Sync 抽象类,非公平锁实现类。</p>
</blockquote>
<p><strong>3.1.1 lock</strong></p>
<p><code>lock()</code>实现方法,首先基于 AQS state 进行 CAS 操作,将 0 =&gt; 1 。</p>
<ul>
<li>若成功,则获取锁成功。</li>
<li>若失败,执行 AQS 的正常的同步状态获取逻辑。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        acquire(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.1.2 tryAcquire</strong></p>
<p><code>tryAcquire(int acquires)</code>实现方法,非公平的方式,获得同步状态。代码如下：</p>
<p>protected final boolean tryAcquire(int acquires) {<br>    return nonfairTryAcquire(acquires);<br>}</p>
<blockquote>
<p>直接调用<code>nonfairTryAcquire(int acquires)</code>方法,非公平锁的方式获得锁。</p>
</blockquote>
<h3 id="3-2-FairSync"><a href="#3-2-FairSync" class="headerlink" title="3.2 FairSync"></a>3.2 FairSync</h3><blockquote>
<p>FairSync 是 ReentrantLock 的内部静态类,实现 Sync 抽象类,公平锁实现类。</p>
</blockquote>
<p><strong>3.2.1 lock</strong></p>
<p><code>lock()</code>实现方法,代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>直接执行 AQS 的正常的同步状态获取逻辑。</p>
</blockquote>
<p><strong>3.2.2 tryAcquire</strong></p>
<p><code>tryAcquire(int acquires)</code>实现方法,公平的方式,获得同步状态。代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="hljs-comment">// &lt;1&gt;</span></span><br><span class="line">                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>比较非公平锁和公平锁获取同步状态的过程,会发现两者唯一的区别就在于:公平锁在获取同步状态时多了一个限制条件 <1> 处的<code>hasQueuedPredecessors()</code>方法,是否有前序节点,即<strong>自己不是首个等待获取同步状态的节点</strong>。</1></p>
</blockquote>
<p>代码如下:</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;  <span class="hljs-comment">//尾节点</span></span><br><span class="line">    Node h = head;  <span class="hljs-comment">//头节点</span></span><br><span class="line">    Node s;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//头节点 != 尾节点</span></span><br><span class="line">    <span class="hljs-comment">//同步队列第一个节点不为null</span></span><br><span class="line">    <span class="hljs-comment">//当前线程是同步队列第一个节点</span></span><br><span class="line">    <span class="hljs-keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法主要做一件事情：主要是判断当前线程是否位于 CLH 同步队列中的第一个。如果是则返回 true ,否则返回 false 。</p>
</blockquote>
<h2 id="4-Lock-接口"><a href="#4-Lock-接口" class="headerlink" title="4. Lock 接口"></a>4. Lock 接口</h2><p><code>java.util.concurrent.locks.Lock</code>接口,定义方法如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取当前锁后返回</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <span class="hljs-comment">//获取锁对过程中可以中断</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//非阻塞对获取锁,如果能够获取就返回true,如果不能返回false</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <span class="hljs-comment">//超时的获取锁 1.在时间内成功获取锁2.超时返回3.被中断</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//释放锁</span></span><br><span class="line"><span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//获取等待组件,该组件和当前的锁绑定,只有当前线程获取了锁,才能调用wait()方法,调用后当前线程的锁被释放</span></span><br></pre></td></tr></table></figure>
<h2 id="5-ReentrantLock"><a href="#5-ReentrantLock" class="headerlink" title="5. ReentrantLock"></a>5. ReentrantLock</h2><p><code>java.util.concurrent.locks.ReentrantLock</code>,实现 Lock 接口,重入锁。</p>
<blockquote>
<p>ReentrantLock 的实现方法,基本是对 Sync 的调用（通过委托的方式）。</p>
</blockquote>
<h3 id="5-1-构造方法"><a href="#5-1-构造方法" class="headerlink" title="5.1 构造方法"></a>5.1 构造方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于<code>fair</code>参数,创建 FairSync 还是 NonfairSync 对象。</p>
</blockquote>
<h3 id="5-2-lock"><a href="#5-2-lock" class="headerlink" title="5.2 lock"></a>5.2 lock</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-lockInterruptibly"><a href="#5-3-lockInterruptibly" class="headerlink" title="5.3 lockInterruptibly"></a>5.3 lockInterruptibly</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-tryLock"><a href="#5-4-tryLock" class="headerlink" title="5.4 tryLock"></a>5.4 tryLock</h3><ul>
<li><code>tryLock()</code>实现方法,在实现时,<strong>希望能快速的获得是否能够获得到锁</strong>,因此即使在设置为 fair = true ( 使用公平锁 ),<strong>依然调用 Sync#nonfairTryAcquire(int acquires)</strong> 方法。</li>
<li>如果真的希望<code>tryLock()</code>还是按照是否公平锁的方式来,可以调用<code>tryLock(0, TimeUnit)</code>方法来实现。</li>
</ul>
<h3 id="5-5-tryLock-0-TimeUnit"><a href="#5-5-tryLock-0-TimeUnit" class="headerlink" title="5.5 tryLock(0, TimeUnit)"></a>5.5 tryLock(0, TimeUnit)</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-unlock"><a href="#5-6-unlock" class="headerlink" title="5.6 unlock"></a>5.6 unlock</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="hljs-number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-7-newCondition"><a href="#5-7-newCondition" class="headerlink" title="5.7 newCondition"></a>5.7 newCondition</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><ol>
<li>与 synchronized 相比,ReentrantLock提供了更多,更加全面的功能,具备更强的扩展性。例如：时间锁等候,可中断锁等候,锁投票。</li>
<li>ReentrantLock 还提供了条件 Condition ,对线程的等待、唤醒操作更加详细和灵活,所以在多个条件变量和高度竞争锁的地方,ReentrantLock 更加适合（以后会阐述Condition）。</li>
<li>ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁,如果成功则继续,否则可以等到下次运行时处理,而 synchronized 则一旦进入锁请求要么成功要么阻塞,所以相比 synchronized 而言,ReentrantLock会不容易产生死锁些。</li>
<li>ReentrantLock 支持更加灵活的同步代码块,但是使用 synchronized 时,只能在同一个 synchronized 块结构中获取和释放。注意,ReentrantLock 的锁释放一定要在 finally 中处理,否则可能会产生严重的后果。</li>
<li>ReentrantLock 支持中断处理,且性能较 synchronized 会好些。</li>
</ol>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="//md.ulovecode.com/static/images/avatar/alipay_v1.jpg" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="//md.ulovecode.com/static/images/avatar/wechatpay_v1.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/05/23/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Kubernetes/%E4%BD%BF%E7%94%A8Kubespray%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2Kubernetes%E9%9B%86%E7%BE%A4%EF%BC%881.14.1%EF%BC%89/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">使用Kubespray在国内自动化部署Kubernetes集群（1.14.1）</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/01/01/Jvm/Java/Java%E8%B0%83%E4%BC%98/">
                <span class="level-item">Java性能调优</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
    <div id="comment-container"></div>
`    <link rel="stylesheet" href="https://code.bdstatic.com/npm/gitalk@1.7.2/dist/gitalk.css">
    <script src="https://code.bdstatic.com/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
    <script>
        var gitalk = new Gitalk({
            clientID: 'ceb3f7e3fadb589ca8f2',
            clientSecret: 'ab52c871230e4d10ee2c2b54a8f9681727302b4d',
            id: 'daa9e3c233d1cd91b77052bf3f4ad1b7',
            repo: 'ulovecode.github.io',
            owner: 'ulovecode',
            admin: "ulovecode",
        })
        gitalk.render('comment-container')
    </script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="https://md.ulovecode.com/static/images/avatar/avatar_v1.jpg?imageView2/0/w/460/h/460" alt="Jovan">
                    
                    
                    <p class="is-size-4 is-block">
                        Jovan
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Keep moving.Don&#39;t settle.
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Shanghai，China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        52
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        14
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        27
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/ulovecode" target="_blank">
                follow</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/ulovecode">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                目录
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#一、synchronized">
        <span class="has-mr-6">1</span>
        <span>一、synchronized</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-实现原理">
        <span class="has-mr-6">1.1</span>
        <span>1. 实现原理</span>
        </a></li><li>
        <a class="is-flex" href="#2-Java-对象头、Monitor">
        <span class="has-mr-6">1.2</span>
        <span>2.Java 对象头、Monitor</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#2-1-Java对象头">
        <span class="has-mr-6">1.2.1</span>
        <span>2.1 Java对象头</span>
        </a></li><li>
        <a class="is-flex" href="#2-2-Monitor">
        <span class="has-mr-6">1.2.2</span>
        <span>2.2 Monitor</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#3-锁优化">
        <span class="has-mr-6">1.3</span>
        <span>3. 锁优化</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#3-1-自旋锁">
        <span class="has-mr-6">1.3.1</span>
        <span>3.1 自旋锁</span>
        </a></li><li>
        <a class="is-flex" href="#3-2-锁消除">
        <span class="has-mr-6">1.3.2</span>
        <span>3.2 锁消除</span>
        </a></li><li>
        <a class="is-flex" href="#3-3-锁粗化">
        <span class="has-mr-6">1.3.3</span>
        <span>3.3 锁粗化</span>
        </a></li><li>
        <a class="is-flex" href="#3-4-锁的升级">
        <span class="has-mr-6">1.3.4</span>
        <span>3.4 锁的升级</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#二、ReentrantLock">
        <span class="has-mr-6">2</span>
        <span>二、ReentrantLock</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#1-简介">
        <span class="has-mr-6">2.1</span>
        <span>1. 简介</span>
        </a></li><li>
        <a class="is-flex" href="#2-Sync-抽象类">
        <span class="has-mr-6">2.2</span>
        <span>2. Sync 抽象类</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#2-1-lock">
        <span class="has-mr-6">2.2.1</span>
        <span>2.1 lock</span>
        </a></li><li>
        <a class="is-flex" href="#2-2-nonfairTryAcquire">
        <span class="has-mr-6">2.2.2</span>
        <span>2.2 nonfairTryAcquire</span>
        </a></li><li>
        <a class="is-flex" href="#2-3-tryRelease">
        <span class="has-mr-6">2.2.3</span>
        <span>2.3 tryRelease</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#3-Sync-实现类">
        <span class="has-mr-6">2.3</span>
        <span>3. Sync 实现类</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#3-1-NonfairSync">
        <span class="has-mr-6">2.3.1</span>
        <span>3.1 NonfairSync</span>
        </a></li><li>
        <a class="is-flex" href="#3-2-FairSync">
        <span class="has-mr-6">2.3.2</span>
        <span>3.2 FairSync</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#4-Lock-接口">
        <span class="has-mr-6">2.4</span>
        <span>4. Lock 接口</span>
        </a></li><li>
        <a class="is-flex" href="#5-ReentrantLock">
        <span class="has-mr-6">2.5</span>
        <span>5. ReentrantLock</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#5-1-构造方法">
        <span class="has-mr-6">2.5.1</span>
        <span>5.1 构造方法</span>
        </a></li><li>
        <a class="is-flex" href="#5-2-lock">
        <span class="has-mr-6">2.5.2</span>
        <span>5.2 lock</span>
        </a></li><li>
        <a class="is-flex" href="#5-3-lockInterruptibly">
        <span class="has-mr-6">2.5.3</span>
        <span>5.3 lockInterruptibly</span>
        </a></li><li>
        <a class="is-flex" href="#5-4-tryLock">
        <span class="has-mr-6">2.5.4</span>
        <span>5.4 tryLock</span>
        </a></li><li>
        <a class="is-flex" href="#5-5-tryLock-0-TimeUnit">
        <span class="has-mr-6">2.5.5</span>
        <span>5.5 tryLock(0, TimeUnit)</span>
        </a></li><li>
        <a class="is-flex" href="#5-6-unlock">
        <span class="has-mr-6">2.5.6</span>
        <span>5.6 unlock</span>
        </a></li><li>
        <a class="is-flex" href="#5-7-newCondition">
        <span class="has-mr-6">2.5.7</span>
        <span>5.7 newCondition</span>
        </a></li></ul></li></ul></li><li>
        <a class="is-flex" href="#三、总结">
        <span class="has-mr-6">3</span>
        <span>三、总结</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
<!--                <a class="footer-logo is-block has-mb-6" href="/">-->
<!--                -->
<!--                    <img src="//md.ulovecode.com/static/images/avatar/logo.jpg" alt="ReentrantLock 与 Synchronized 原理分析" height="28">-->
<!--                -->
<!--                </a>-->
<!--                <p class="is-size-7">-->
<!--                &copy; 2024 Jovan&nbsp;-->
<!--                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a-->
<!--                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>-->
<!--                -->
<!--                </p>-->
                <p class="is-size-7">
                    
                </p>
            </div>
<!--    备案号信息        -->
            <center>
            <a href="http://www.beian.miit.gov.cn/" target="_blank" style="color: rgba(0,0,0,0.65)"  noopenerrel="" > 鄂ICP备17027965号-1</a>
            </center>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>

<script> pangu.spacingPage();/* 这个是博客全局都进行自动加空格处理 */ </script>

    <script src="https://code.bdstatic.com/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://code.bdstatic.com/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    
    
    <script src="https://code.bdstatic.com/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://code.bdstatic.com/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="https://md.ulovecode.com/static/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://code.bdstatic.com/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="https://md.ulovecode.com/static/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://code.bdstatic.com/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="https://md.ulovecode.com/static/js/clipboard.js" defer></script>
    

    
    
    


<script src="https://md.ulovecode.com/static/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: 'https://md.ulovecode.com/static/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="https://md.ulovecode.com/static/js/insight.js" defer></script>
<link rel="stylesheet" href="https://md.ulovecode.com/static/css/search.css">
<link rel="stylesheet" href="https://md.ulovecode.com/static/css/insight.css">
    
</body>
</html>